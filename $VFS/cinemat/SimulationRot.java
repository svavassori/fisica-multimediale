package cinemat;import util.*;import numeric.*;/** * A base class for the simulation of pure rotational motion * @author Pasquale Foggia * @version 0.99, Jan 1997 */public class SimulationRot extends Simulation  { Settings settings;    public SimulationRot(Settings settings)      { this.settings=settings;      }        /**     * Runts the simulation up to the time specified by     * the user.     * The values are saved at intervals specified by the user     */        public synchronized void runUpTo(double endTime, double timeStep)      { steps=(int)Math.ceil(endTime/timeStep)+1;        int i;        double vang=settings.vel_ang_base;        double r=settings.raggio;        if (settings.moto_relativo==Settings.ROTATORIO)          vang+=settings.vel_rel_ang;        t=new double[steps];        x=new double[steps];        y=new double[steps];        for(i=0; i<steps; i++)          { t[i]=i*timeStep;            double ang=vang*t[i];            x[i]=r*Math.cos(ang);            y[i]=r*Math.sin(ang);          }      }    /**     * Types of output information available     * The time is included, and should be always outpun n. 0     */    public synchronized int getOutputCount()      {        if (settings.ShowProjection)        return 14;        else        return 8;      }    /**     * Names associated to the output information     * The time is included, and should be always outpun n. 0     */    public synchronized String getOutputName(int i)      { if  (settings.ShowProjection)       {       final String name[]={                        "Tempo",                        "Posizione X",                        "Posizione Y",                        "Raggio",                        "Angolo",                        "Velocità X",                        "Velocità Y",                        "Velocità",                        "Velocità angolare",                        "Accelerazione X",                        "Accelerazione Y",                        "Accelerazione centripeta",                        "Frequenza",                        "Periodo"                      };        return name[i];        }        else        {         final String name[]={                        "Tempo",                        "Raggio",                        "Angolo",                        "Velocità",                        "Velocità angolare",                        "Accelerazione centripeta",                        "Frequenza",                        "Periodo"                      };        return name[i];        }      }    /**     * Short names associated to the output information     * The time is included, and should be always outpun n. 0     */    public synchronized String getOutputShortName(int i)      {        if  (settings.ShowProjection)        {        final String name[]={                        "t[s]",                        "X[m]",                        "Y[m]",                        "R[m]",                        "Ang[rad]",                        "Vx[m/s]",                        "Vy[m/s]",                        "V[m/s]",                        "Va[rad/s]",                        "Ax[m/s^2]",                        "Ay[m/s^2]",                        "Ac[m/s^2]",                        "Freq[Hz]",                        "T[s]"                      };        return name[i];        }        else        {        final String name[]={                        "t[s]",                        "R[m]",                        "Ang[rad]",                        "V[m/s]",                        "Va[rad/s]",                        "Ac[m/s^2]",                        "Freq[Hz]",                        "T[s]"                      };        return name[i];        }      }    /**     * Value of output information     * The time is included, and should be always outpun n. 0     */    public synchronized double getOutput(int i, int step)      {         double vang=settings.vel_ang_base;        if (settings.moto_relativo==Settings.ROTATORIO)          vang+=settings.vel_rel_ang;        double r=settings.raggio;        double ang=vang*t[step];        double sin=Math.sin(ang);        double cos=Math.cos(ang);        if  (settings.ShowProjection)        {        switch(i)          { case 0:              return t[step];            case 1:              return x[step];            case 2:              return y[step];            case 3:              return r;            case 4:              return ang;            case 5:              return -r*sin*vang;            case 6:              return +r*cos*vang;            case 7:              return r*vang;            case 8:              return vang;            case 9:              return -r*cos*vang*vang;            case 10:              return -r*sin*vang*vang;            case 11:              return r*vang*vang;            case 12:              return Math.abs(vang/(2*Math.PI));            case 13:              return Math.abs(2*Math.PI/vang);            default:              throw new IllegalArgumentException();          }        }        else        {         switch(i)          { case 0:              return t[step];            case 1:              return r;            case 2:              return ang;            case 3:              return r*vang;            case 4:              return vang;            case 5:              return r*vang*vang;            case 6:              return Math.abs(vang/(2*Math.PI));            case 7:              return Math.abs(2*Math.PI/vang);            default:              throw new IllegalArgumentException();          }        }             }    /**     * Returns the vector of the indices of the most interesting outputs     * to be displayed during the simulation     */    public int[] getInterestingInfo()      {        if  (settings.ShowProjection)        {        int n=10;        int idx[]=new int[n];        idx[0]=0;        idx[1]=1;        idx[2]=2;        idx[3]=3;        idx[4]=4;        idx[5]=5;        idx[6]=6;        idx[7]=8;        idx[8]=12;        idx[9]=13;        return idx;        }        else        {         int n=6;         int idx[]=new int[n];         idx[0]=0;         idx[1]=1;         idx[2]=2;         idx[3]=4;         idx[4]=6;         idx[5]=7;         return idx;        }      }    public double getSin(int step)      { if (step>=steps)          return 0;        double vang=settings.vel_rel_ang;        if (settings.moto_relativo==Settings.ROTATORIO)          vang+=settings.vel_rel_ang;        double ang=vang*t[step];        return Math.sin(ang);      }    public double getCos(int step)      { if (step>=steps)          return 1;        double vang=settings.vel_rel_ang;        if (settings.moto_relativo==Settings.ROTATORIO)          vang+=settings.vel_rel_ang;        double ang=vang*t[step];        return Math.cos(ang);      }  }