package cinemat;import util.*;/** * A base class for the simulation types * @author Pasquale Foggia * @version 0.99, Jan 1997 */public abstract class Simulation  {     protected double t[]={0};    protected double x[]={0}, y[]={0};    protected int steps=0;    /**     * Runs the simulation up to the time specified by     * the user.     * The values are saved at intervals specified by the user     */        public abstract /*synchronized*/ void runUpTo(double endTime, double timeStep);    /**     * Returns the number of saved steps     */    public synchronized int getStepCount()      { return steps;      }    public synchronized double getTime(int step)      { return t[step];      }    public synchronized double getX(int step)      { return x[step];      }    public synchronized double getY(int step)      { return y[step];      }    /**     * Returns the min and max values of x and y     * xx[0] and yy[0] will receive the min,     * xx[1] and yy[1] will receive the max.     */    public /*synchronized*/ void getMinMaxXY(double xx[], double yy[])      { int i;        if (steps<1)          { xx[0]=0;            yy[0]=0;            xx[1]=0;            yy[1]=0;            return;          }        xx[0]=x[0];        xx[1]=x[0];        yy[0]=y[0];        yy[1]=y[0];        for(i=1; i<steps; i++)          { if (x[i]<xx[0])              xx[0]=x[i];            else if (x[i]>xx[1])              xx[1]=x[i];            if (y[i]<yy[0])              yy[0]=y[i];            else if (y[i]>yy[1])              yy[1]=y[i];          }                }    /**     * Types of output information available     * The time is included, and should be always outpun n. 0     */    public abstract  /*synchronized*/ int getOutputCount();    /**     * Search the output n. with the given name.     * If not found, returns getOutputCount (always time).     */    public synchronized int searchOutputName (String name) {        int i;                for (i=0;i<getOutputCount();i++)                {//                System.out.println(getOutputName(i)+name);                if (getOutputName(i).equals(name))                        {  //                              System.out.println("Trovata");                                return i;                        }                }           return getOutputCount();    }            /**     * Names associated to the output information     * The time is included, and should be always outpun n. 0     */    public synchronized String getOutputName(int i)      { return getOutputShortName(i);      }    /**     * Short names associated to the output information     * The time is included, and should be always outpun n. 0     */    public abstract /*synchronized*/ String getOutputShortName(int i);    /**     * Value of output information     * The time is included, and should be always outpun n. 0     */    public abstract /*synchronized*/ double getOutput(int i, int step);        public String getTableHeading()      { int i;        int n=getOutputCount();        StringBuffer sb=new StringBuffer();        for(i=0; i<n; i++)          {             sb.append(Format.format("^11", getOutputShortName(i)));            sb.append("\t");          }        return sb.toString();      }    public synchronized String getTableRow(int step)      { int i;        int n=getOutputCount();        StringBuffer sb=new StringBuffer();        for(i=0; i<n; i++)          {             sb.append(Format.format("11.3", getOutput(i, step)));            sb.append("\t");          }        return sb.toString();      }    /**     * Returns the vector of the indices of the most interesting outputs     * to be displayed during the simulation     */    public int[] getInterestingInfo()      { int i, n=getOutputCount();        int idx[]=new int[n];        for(i=0; i<n; i++)          idx[i]=i;        return idx;      }  }