package cinemat;import util.*;import numeric.*;/** * A base class for the simulation of pure translational motion * @author Pasquale Foggia * @version 0.99, Jan 1997 */public class SimulationTransl extends Simulation  { Settings settings;    public SimulationTransl(Settings settings)      { this.settings=settings;      }        /**     * Runts the simulation up to the time specified by     * the user.     * The values are saved at intervals specified by the user     */        public synchronized void runUpTo(double endTime, double timeStep)      { steps=(int)Math.ceil(endTime/timeStep)+1;        int i;        double vb=settings.vel_base;        double a=settings.acc_base;        double vrx=settings.vel_rel_x;        double vry=settings.vel_rel_y;        double x0=settings.x0;                if (settings.moto_relativo==Settings.NESSUNO)          { vrx=vry=0;          }        t=new double[steps];        x=new double[steps];        y=new double[steps];        for(i=0; i<steps; i++)          { t[i]=i*timeStep;            x[i]=x0+(vb+vrx)*t[i]+0.5*a*t[i]*t[i];            y[i]=vry*t[i];          }      }    /**     * Types of output information available     * The time is included, and should be always outpun n. 0     */    public synchronized int getOutputCount()      {// se il moto  uniforme senza trascinamento       if ((settings.acc_base==0) && ((settings.moto_relativo==Settings.NESSUNO) || ((settings.vel_rel_x==0) && (settings.vel_rel_y==0))) )       return 3;       // se il moto  uniforme ma c'  trascinamento       else if ((settings.acc_base==0) && (settings.moto_relativo==Settings.TRASLATORIO)                && ((settings.vel_rel_x!=0) || (settings.vel_rel_y!=0)))       return 6;       // se il moto  uniformemente accelerato ma non c' trascinamento       else if ((settings.acc_base!=0) && ((settings.moto_relativo==Settings.NESSUNO) || ((settings.vel_rel_x==0) && (settings.vel_rel_y==0))) )       return 4;       else return 8;      }    /**     * Names associated to the output information     * The time is included, and should be always outpun n. 0     */    public synchronized String getOutputName(int i)      {       if ((settings.acc_base==0) && ((settings.moto_relativo==Settings.NESSUNO) || ((settings.vel_rel_x==0) && (settings.vel_rel_y==0))))              {        String name[]={                        "Tempo",                        "Posizione X",                                                                                   "Velocità X"                                           };               return name[i];        }       else if ((settings.acc_base!=0) && ((settings.moto_relativo==Settings.NESSUNO) || ((settings.vel_rel_x==0) && (settings.vel_rel_y==0))))       {        String name[]={                        "Tempo",                        "Posizione X",                                                                                    "Velocità X",                        "Accelerazione X"                                           };               return name[i];               }               else        {        String name[]={                        "Tempo",                        "Posizione X",                        "Posizione Y",                        "Velocità X",                        "Velocità Y",                        "Velocità",                        "Accelerazione X",                        "Accelerazione Y"                      };               return name[i];        }      }    /**     * Short names associated to the output information     * The time is included, and should be always outpun n. 0     */    public synchronized String getOutputShortName(int i)      {       if ((settings.acc_base==0) && ((settings.moto_relativo==Settings.NESSUNO) || ((settings.vel_rel_x==0) && (settings.vel_rel_y==0))))        {String name[]={                        "t[s]",                        "X[m]",                                                                                                "Vx[m/s]"                                              };               return name[i];                }        else if ((settings.acc_base!=0) && ((settings.moto_relativo==Settings.NESSUNO) || ((settings.vel_rel_x==0) && (settings.vel_rel_y==0))))        {        String name[]={                        "t[s]",                        "X[m]",                                                                                                "Vx[m/s]",                        "Ax[m/s^2]"                                              };                 return name[i];        }        else        {String name[]={                        "t[s]",                        "X[m]",                        "Y[m]",                        "Vx[m/s]",                        "Vy[m/s]",                        "V[m/s]",                        "Ax[m/s^2]",                        "Ay[m/s^2]"                      };               return name[i];        }      }    /**     * Value of output information     * The time is included, and should be always outpun n. 0     */    public synchronized double getOutput(int i, int step)      {         double vb=settings.vel_base;        double a=settings.acc_base;        double vrx=settings.vel_rel_x;        double vry=settings.vel_rel_y;        if (settings.moto_relativo==Settings.NESSUNO)          { vrx=vry=0;          }       // moto uniforme senza trascinamento       if ((settings.acc_base==0) && ((vrx==0) && (vry==0)))          {                switch(i)                { case 0:                        return t[step];                case 1:                        return x[step];                case 2:                        return vb;                default:                        throw new IllegalArgumentException();                }          }        // moto uniformemente accelerato senza trascinamento        else if ((settings.acc_base!=0) && ((vrx==0) && (vry==0)))        {                switch(i)                { case 0:                        return t[step];                case 1:                        return x[step];                case 2:                        return vb+vrx+a*t[step];                case 3:                        return a;                default:                        throw new IllegalArgumentException();                }        }          else          {                switch(i)                { case 0:                        return t[step];                case 1:                        return x[step];                case 2:                        return y[step];                case 3:                        return vb+vrx+a*t[step];                case 4:                        return vry;                case 5:                        return Functions.hypot(getOutput(3,step), getOutput(4, step));                case 6:                        return a;            case 7:              return 0;                default:                        throw new IllegalArgumentException();                }          }      }  }