/* * ODESolver.java * Integrates Ordinary Differential Equation systems with the * method of Runge-Kutta-Fehlberg */package numeric;import numeric.ODE;import numeric.VectorNorm;import numeric.EuclideanNorm;/** * Allows a numeric integration of an Ordinary Differential Equations  * system. The employed algorithm is Runge-Kutta-Fehlberg with orders * 4 and 5 * @author   Pasquale Foggia * @version  0.99, 17 Dec 1997 */public class ODESolver  { private static final VectorNorm defaultNorm=new EuclideanNorm();    private static final double minDouble=1000.0*Double.MIN_VALUE;    private static final double epsDouble=10e-15;    private int status;  // One of the following values    /**     * Value of the status. All is fine.     */    public static final int OK=0;    /**     * Value of the status. One of the parameters was not correct.     */    public static final int BAD_PARAMETERS=-1;    /**     * Value of the status. To achieve the desired precision a     * step lower than the user provided minimum is required.     */    public static final int STEP_TOO_LOW=1;    /**     * Value of the status. The number of iterations has exceeded     * the user provided maximum.     */    public static final int TOO_MANY_ITERATIONS=2;    /**     * Value of the status. The solution is gone into an     * endless loop. This can happen if 'tolerant' is set to true.     */    public static final int LOOP=3;    /**     * Returns the status of the solver, which can be one of     * OK, BAD_PARAMETERS, STEP_TOO_LOW, TOO_MANY_ITERATIONS     */    public int getStatus()       { return status;       }    /**     * Returns true if the status is OK     */    public boolean isOk()      { return status==OK;      }    private ODE ode; // The system of equations to solve    private int n;   // The dimension of the system    private int maxiter; // Maximum number of iterations    private double minstep, // Min value of the step                   maxstep; // max value of the step    private double maxerror; // max absolute local error    private double step;    // Current value of the step    private double x;       // Current value of x    private double y[];     // Current value of y    private VectorNorm norm=defaultNorm; // Vector norm to be used    private double k1[], k2[], k3[], k4[], k5[], k6[];    private double temp[];    private double temp2[];    private boolean tolerant=false;    /**     * Creates a new ODE solver for the specified system of equations     * @param odeSystem   the system to solve.     * @param x  initial value of x.     * @param y  initial value of y. This vector is shared, not copied by     *           the constructor, so it cannot be reused.     * @param step  Initial value of the step, which is used also as     *             maximum step value     * @param maxerror  the maximum absolute local error accepted in the     *                  solution     */    public ODESolver(ODE odeSystem, double x, double y[],                      double step, double maxerror)      { ode=odeSystem;        n=ode.getDimension();        this.x=x;        this.y=y;        status=OK;        maxiter=30;        minstep=0.001*step;        this.step=step;        maxstep=step*10;        this.maxerror=maxerror;        check();        k1=new double[n];        k2=new double[n];        k3=new double[n];        k4=new double[n];        k5=new double[n];        k6=new double[n];        temp=new double[n];        temp2=new double[n];      }    private void check()      { status=OK;        if (minstep<minDouble)          minstep=minDouble;        if (step<minstep || step>maxstep)          status=BAD_PARAMETERS;        if (maxerror<=minDouble)          status=BAD_PARAMETERS;        if (maxiter<1)          status=BAD_PARAMETERS;        if (ode.getDimension()!=y.length)          status=BAD_PARAMETERS;      }    /**     * Determines if the solver is <I>tolerant</I>, i.e. if it     * proceeds even though the desired precision is not met     */    public void setTolerant(boolean tol)      { tolerant=tol;      }    /**      * Returns the dimension of the system (length of the y vector)     */    public int getDimension()      { return n;      }    /**     * Returns the maximum number of iterations allowed      * by the algorithm to attain the desired precision.     */    public int getMaxIter()      { return maxiter;      }    /**     * Change the maximum number of iterations allowed      * by the algorithm to attain the desired precision.     * The default value is 30.     */    public void setMaxIter(int maxiter)      { this.maxiter=maxiter;        check();      }    /**     * Returns the minimum step allowed by the algorithm      * to attain the desired precision     */    public double getMinStep()      { return minstep;      }    /**     * Changes the minimum step allowed by the algorithm      * to attain the desired precision     */    public void setMinStep(double minstep)      { if (minstep<minDouble)          minstep=minDouble;        this.minstep=minstep;        if (step<minstep)          step=minstep;        check();      }    /**     * Returns the maximum step allowed by the algorithm      * to attain the desired precision     */    public double getMaxStep()      { return maxstep;      }    /**     * Changes the maximum step allowed by the algorithm      * to attain the desired precision     */    public void setMaxStep(double maxstep)      { this.maxstep=maxstep;        if (step>maxstep)          step=maxstep;        check();      }    /**     * Returns the maximum error allowed       */    public double getMaxError()      { return maxerror;      }    /**     * Changes the maximum error allowed       */    public void setMaxError(double maxerror)      { this.maxerror=maxerror;        check();      }    /**     * Gets the current value of x     */    public double getX()      { return x;      }    /**     * Changes the current value of x     */    public void setX(double x)      { this.x=x;      }    /**     * Gets the current value of y.     * Returns a vector that is shared with the ODE Solver.     */    public double[] getY()      { return y;      }    /**     * Gets the current value of y in a vector provided     * by the user     */    public void getY(double dest[])      { int i;        int lim=Math.min(y.length, dest.length);        for(i=0; i<lim; i++)          dest[i]=y[i];      }    /**     * Changes the current value of y     * The vector y is shared (i.e. the ODE solver does not make a      * local copy).     */    public void setY(double y[])      { this.y=y;        check();      }    /**     * Gets the current value of the step     */    public double getStep()      { return step;      }    /**     * Changes the current value of the step     */    public void setStep(double step)      { if (step<minstep)          step=minstep;        if (step>maxstep)          step=maxstep;        this.step=step;      }    /**     * Sets a new vector norm to evaluate the error.     * The default norm is the euclidean norm     * @see EuclideanNorm     */    public void setNorm(VectorNorm norm)      { if (norm!=null)          this.norm=norm;      }    /**     * Executes a step of the Runge-Kutta-Fehlberg algorithm     * @return the status of the solver     */    public int nextStep()      { int iter=0;        double r, q;        double x_before=x;        do          { iter++;            ode.derive(x, y, temp);            setVector(step, temp, k1);            int i;            setVector(y, 1.0/4.0, k1, temp);            ode.derive(x+1.0/4.0*step, temp, temp2);            setVector(step, temp2, k2);            setVector(y, 3.0/32.0, k1, temp);            setVector(temp, 9.0/32.0, k2, temp2);            ode.derive(x+3.0/8.0*step, temp2, temp);            setVector(step, temp, k3);            setVector(y, 1932.0/2197.0, k1, temp);            setVector(temp, -7200.0/2197.0, k2, temp2);            setVector(temp2, 7296.0/2197.0, k3, temp);            ode.derive(x+12.0/13.0, temp, temp2);            setVector(step, temp2, k4);            setVector(y, 439.0/216.0, k1, temp);            setVector(temp, -8.0, k2, temp2);            setVector(temp2, 3680.0/513.0, k3, temp);            setVector(temp, -845.0/4104.0, k4, temp2);            ode.derive(x+step, temp2, temp);            setVector(step, temp, k5);            setVector(y, -8.0/27.0, k1, temp);            setVector(temp, 2.0, k2, temp2);            setVector(temp2, -3544.0/2565.0, k3, temp);            setVector(temp, 1859.0/4104.0, k4, temp2);            setVector(temp2, -11.0/40.0, k5, temp);            ode.derive(x+0.5*step, temp, temp2);            setVector(step, temp2, k6);            // Error computation            setVector(1.0/360.0, k1, temp);            setVector(temp, -128.0/4275.0, k3, temp2);            setVector(temp2, -2197.0/75240.0, k4, temp);            setVector(temp, 1.0/50.0, k5, temp2);            setVector(temp2, 2.0/55.0, k6, temp);            r=norm.norm(temp)/step;            if (r > maxerror*epsDouble)              q=0.84*Math.pow(maxerror/r, 0.25);            else              q=4.0;            if (q<0.1)              q=0.1;            else if (q>4.0)              q=4.0;            if (r<=maxerror || (tolerant && step*q<minstep))              { // approssimation accepted                x+=step;                setVector(y, 25.0/216.0, k1, temp);                setVector(temp, 1408.0/2565.0, k3, temp2);                setVector(temp2, 2197.0/4104.0, k4, temp);                setVector(temp, -1.0/5.0, k5, y);              }            // Computation of new step            step*=q;            if (step>maxstep)              step=maxstep;            if (tolerant && step<minstep)              { step=minstep;                break;              }          } while (step>=minstep && r>=maxerror && iter<maxiter);        if (step<minstep)          status=STEP_TOO_LOW;        else if (iter>=maxiter)          status=TOO_MANY_ITERATIONS;        if (x==x_before && status==OK)          /*          { System.out.println("###x="+x+" step="+step+" r="+r+" q="+q+                               " me="+maxerror+" ms="+minstep+                               " i="+iter+ " mi="+maxiter);            int i;            for(i=0; i<n; i++)              System.out.print("  y["+i+"]="+y[i]);            System.out.println();            throw new RuntimeException("Loop in nextStep()");          }*/          status=LOOP;        return status;      }    // y = a*x    private void setVector(double a, double x[], double y[])      { int i;        for(i=0; i<n; i++)          y[i]=a*x[i];      }    // y = a*x+w    private void setVector(double w[], double a, double x[], double y[])      { int i;        for(i=0; i<n; i++)          y[i]=w[i]+a*x[i];      }  }