package dinam2;import dinam2.*;import numeric.*;/** * Simulazione del moto in un campo elastico * @author Pasquale Foggia * @version 0.99, Jan 1998 */public class SimulationElast extends Simulation implements ODE  {     double vx[], vy[];    double ax[], ay[];    double mass, x0, y0, vx0, vy0, x00, y00, vx00, vy00;    boolean exact;    ODESolver solver=null;    ODEInterpolator interpolator=null;    Settings settings;    public SimulationElast(Settings settings,                           double mass,                          double x0, double y0,                           double vx0, double vy0)      { this.settings=settings;        this.mass=mass;        this.x0=x0;        this.y0=y0;        this.vx0=vx0;        this.vy0=vy0;        this.x00=x0;        this.y00=y0;        this.vx00=vx0;        this.vy00=vy0;        t1=0;        t2=0;        exact=(settings.resistenza_laminare==0 &&               settings.resistenza_turbolenta==0);        x=new double[1];        x[0]=x0;        y=new double[1];        y[0]=y0;      }   public double getMass()      { return mass;      }   public double getInitialVelX()      { return vx00;      }   public double getInitialVelY()      { return vy00;      }    public int getOutputCount()      { return 11;      }    public String getOutputName(int i)      { final String names[]= { "Posizione X",                          "Posizione Y",                          "Velocità",                          "Velocità X",                          "Velocità Y",                          "Accelerazione",                          "Accelerazione X",                          "Accelerazione Y",                          "Energia cinetica",                          "Energia potenziale",                          "Energia"                        };        return names[i];      }    public String getOutputShortName(int i)      { final String names[]= { "X[m]",                          "Y[m]",                          "V[m/s]",                          "Vx[m/s]",                          "Vy[m/s]",                          "A[m/s^2]",                          "Ax[m/s^2]",                          "Ay[m/s^2]",                          "Ek[J]",                          "Ep[J]",                          "E[J]"                        };         return names[i];      }    public double getOutput(int i, int step)      { switch(i)        { case 0:            return x[step];          case 1:            return y[step];          case 2:            return Functions.hypot(vx[step], vy[step]);          case 3:            return vx[step];          case 4:            return vy[step];          case 5:            return Functions.hypot(ax[step], ay[step]);          case 6:            return ax[step];          case 7:            return ay[step];          case 8:            return 0.5*mass*Functions.hypot2(vx[step], vy[step]);          case 9:            return -settings.fx*x[step]-settings.fy*y[step]                   +0.5*settings.costante_elastica*                          Functions.hypot2(x[step],y[step]);          case 10:            return getOutput(8, step)+getOutput(9, step);          default:            throw new IllegalArgumentException();        }      }    public void runUpTo(double endTime, double timeStep)      { if (endTime<t2)          throw new IllegalArgumentException();        t1=t2;        if (steps>0)        { x0=x[steps-1];          y0=y[steps-1];          vx0=vx[steps-1];          vy0=vy[steps-1];        }        steps=(int)Math.ceil((endTime-t1)/timeStep)+1;        t2=t1+(steps-1)*timeStep;        t=new double[steps];        x=new double[steps];        y=new double[steps];        vx=new double[steps];        vy=new double[steps];        ax=new double[steps];        ay=new double[steps];        int i;        for(i=0; i<steps; i++)          t[i]=t1+i*timeStep;        if (exact)          { double Ax, Bx, omega, phix;            double Ay, By, phiy;            double px, qx, py, qy;            double k=settings.costante_elastica/mass;            Bx=settings.fx/mass/k;            By=settings.fy/mass/k;            omega=Math.sqrt(k);            px=x00-Bx;            py=y00-By;            qx=vx00/omega;            qy=vy00/omega;            Ax=Functions.hypot(px, qx);            Ay=Functions.hypot(py, qy);            phix=Math.atan2(px, qx);            phiy=Math.atan2(py, qy);                        for(i=0; i<steps; i++)              { ax[i]=-k*Ax*Math.sin(omega*t[i]+phix);                ay[i]=-k*Ay*Math.sin(omega*t[i]+phiy);                vx[i]=omega*Ax*Math.cos(omega*t[i]+phix);                vy[i]=omega*Ay*Math.cos(omega*t[i]+phiy);                x[i]=Ax*Math.sin(omega*t[i]+phix)+Bx;                y[i]=Ay*Math.sin(omega*t[i]+phiy)+By;              }          }        else          {             if (solver==null)              { double yy[]=new double[4];                yy[0]=x0;                yy[1]=y0;                yy[2]=vx0;                yy[3]=vy0;                solver=new ODESolver(this, t1, yy, timeStep/4, 1e-5);              }            solver.setMaxStep(timeStep/4);            solver.setMinStep(timeStep/400);            solver.setMaxError(1e-5+                       1e-4*Math.max( Functions.hypot(x0, y0),                                       Functions.hypot(vx0, vy0) ));            if (interpolator==null)              interpolator=new ODEInterpolator(solver);            double yy[]=new double[4];            for(i=0; i<steps; i++)              { int status=interpolator.interpolate(t[i], yy);                if (status!=ODEInterpolator.OK)                  throw new RuntimeException(                          "ODEInterpolator error: status=="+status);                x[i]=yy[0];                y[i]=yy[1];                vx[i]=yy[2];                vy[i]=yy[3];                computeAcceleration(x[i], y[i], vx[i], vy[i], yy);                ax[i]=yy[0];                ay[i]=yy[1];              }          }                      }    public int getDimension()      { return 4;      }    public void derive(double t, double yy[], double yy1[])      { yy1[0]=yy[2];        yy1[1]=yy[3];        double zz[]={0,0};        computeAcceleration(yy[0], yy[1], yy[2], yy[3], zz);        yy1[2]=zz[0];        yy1[3]=zz[1];      }    public void computeAcceleration(double x, double y,                                     double vx, double vy, double a[])      { double v=Functions.hypot(vx, vy);        double fx=settings.fx;        double fy=settings.fy;        fx -= settings.costante_elastica*x;        fy -= settings.costante_elastica*y;                if (v>0)          { double rl=v*settings.resistenza_laminare;            double rt=v*v*settings.resistenza_turbolenta;            double r=rl+rt;            fx-=r*vx/v;            fy-=r*vy/v;          }        a[0]=fx/mass;        a[1]=fy/mass;      }  }