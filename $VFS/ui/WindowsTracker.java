package ui;import java.awt.event.*;import java.awt.*;import java.util.Stack;import java.util.EmptyStackException;public class WindowsTracker implements Runnable, WindowListener,FocusListener {    static boolean enabled;    static Stack s;    static WindowsTracker firsttracker;    static Thread firstthread;    static public Frame firstwin;        static volatile boolean tobacktofront;         static int iteration;        static final int maxiteration=5;	static public boolean fullscreen;        // initialize static variables    static {        firsttracker=new WindowsTracker();        firstthread=new Thread (firsttracker);        firstthread.start();                firstwin=new Frame(); // padre di tutti i frame!        firstwin.resize(1,1);        firstwin.setLocation(10000,10000);        firstwin.setTitle("LaboratoriDiFisica");        firstwin.setVisible(true);        //firstwin.setIconImage(il.load("icons/simul.gif"));        		fullscreen=false;        enabled=false;        tobacktofront=false;        iteration=maxiteration;        s=new Stack();    }    public static Window getLastOpenedWin () { // gets the last opened window to make a gerarchy        try {            return ((Window)s.peek());	    } catch (EmptyStackException exp) {            return firstwin;        }    }    // counter     synchronized boolean counterExpired() {        return false; //iteration<0;            }    synchronized void resetCounter() {        iteration=maxiteration;    }    synchronized void decCounter() {        iteration--;    }    // FocusEvent Methods    synchronized public void focusGained (FocusEvent e) {        System.out.println("focus gained");    }    synchronized public void focusLost (FocusEvent e) {        System.out.print("focus lost");        if (e.isTemporary())            System.out.println(" temporary");        else            System.out.println(" not temporary");    }    // WindowEvent Methods    synchronized public void windowDeiconified(WindowEvent e) {        System.out.println("win deiconified");    }    synchronized public void windowIconified(WindowEvent e) {        System.out.println("win iconified");    }        synchronized public void windowOpened (WindowEvent e) {        System.out.println("win open");            }    synchronized public void windowClosing (WindowEvent e) {        System.out.println("win closing");        e.getWindow().handleEvent (new Event(e.getWindow(), Event.WINDOW_DESTROY, null) );    }    private void removeWinFromStack (Window w) {        Stack tmp=new Stack();        if (!s.empty() && s.peek().equals(w))            s.pop();        else { // out of order deleting            while (!s.empty())                if (!s.peek().equals(w))                    tmp.push(s.pop());                else                    s.pop();            while (!tmp.empty())                s.push(tmp.pop());        }    }    synchronized public void windowClosed (WindowEvent e) {        System.out.println("win closed");        removeWinFromStack(e.getWindow());    }        synchronized public void windowActivated (WindowEvent e) {        System.out.println("win activated");            }    synchronized public void windowDeactivated (WindowEvent e) {        try {            if (e.getWindow()==((Window)s.peek()) )                System.out.print("topmost win deactivated");            else                System.out.print("generic win deactivated");	    } catch (EmptyStackException exp) {            System.out.print("generic win deactivated");        }        /*        try {            Stack tmp=new Stack();            if (isEnabled() && !counterExpired() && e.getWindow().isShowing() && s.peek().equals(e.getWindow()) && !tobacktofront) {                decCounter();                System.out.print("*");                if (firstthread!=null)                    firstthread.suspend();                tobacktofront=true;                while (!s.empty()) {                    tmp.push(s.pop());                    ((Window)tmp.peek()).removeWindowListener(this);                    ((Window)tmp.peek()).setVisible(false);                }                while (!tmp.empty()) {                    s.push(tmp.pop());                    //((Window)s.peek()).toFront();                    ((Window)s.peek()).setVisible(true);                    //((Window)s.peek()).requestFocus();                    //((Window)s.peek()).toFront();                    ((Window)s.peek()).addWindowListener(this);                }                tobacktofront=false;                if (firstthread!=null)                    firstthread.resume();            }        } catch (EmptyStackException exp) {        }        System.out.println("");		/*try {			while (!s.empty()) {				((Window)s.peek()).removeWindowListener(firsttracker);				((Window)s.peek()).dispose();				firsttracker.removeWinFromStack(((Window)s.peek()));					}		} catch (EmptyStackException exp) {        }*/            }	    public void run() {        while (true) {            try {			   	((Window)s.peek()).toFront();			    		    } catch (EmptyStackException exp) {            }            sleep(10);            /*resetCounter();            sleep(1000);*/        }    };    // constructor    public WindowsTracker () {    }    // static methods...    synchronized static public void adjust() {/*        try {            ((Window)s.peek()).removeWindowListener(firsttracker);            ((Window)s.peek()).setVisible(false);            ((Window)s.peek()).setVisible(true);			//((Window)s.peek()).toFront();            ((Window)s.peek()).addWindowListener(firsttracker);        } catch (EmptyStackException e) {            ;        }*/    }    synchronized static public void add(Window w) {        //if (firstwin==null || s.empty())        //    firstwin=(Frame)w;        s.push(w);        w.addWindowListener(firsttracker);        w.toFront();        w.requestFocus();                }        synchronized static public void delete(Window w) {        w.removeWindowListener(firsttracker);        firsttracker.removeWinFromStack(w);        try {		   	((Window)s.peek()).toFront();			    	    } catch (EmptyStackException exp) {        }    }        synchronized static public void reset() {        try  {            while (!s.empty()) {                delete((Window)s.peek());            }         } catch (EmptyStackException exp) {        }        s=new Stack();    }    synchronized static public void disposeAndReset() {        try  {            while (!s.empty()) {                ((Window)s.peek()).hide();                                ((Window)s.peek()).dispose();                delete((Window)s.peek());            }        } catch (EmptyStackException exp) {        }        s=new Stack();    }    synchronized static public void enable(boolean _enabled) {        enabled=_enabled;    }        synchronized static public boolean isEnabled() {        return enabled;    }        static public void sleep (int millisecs) {        try  {            Thread.sleep(1000); // wait 1/10 of sec                       } catch (InterruptedException e) {            ;        }    }}