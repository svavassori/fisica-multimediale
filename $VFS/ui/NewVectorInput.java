package ui;import util.*;import numeric.*;import java.awt.*;/** * A control for asking the user a bi-dimensional vector * @author P. Foggia * @version 0.99, Dec 1997 */public class NewVectorInput extends Panel  { NewVectorInputCanvas canvas;    NumericInput modulus;    NumericInput angle;    NumericInput xComp;    NumericInput yComp;    double minx, maxx, miny, maxy;    double MAXMOD;    int v_scale;    /**     * Create a Vector Input with the specified ranges for the x     * and the y component     */    public NewVectorInput(double minx, double maxx, double miny, double maxy, int v_scale)      { this.minx=minx;        this.miny=miny;        this.maxx=maxx;        this.maxy=maxy;        this.v_scale=v_scale;         double c_width=maxx-minx;        double c_height=maxy-miny;        //double scale_x=chooseScale(c_width);        //double scale_y=chooseScale(c_height);        double scale_x=chooseScale(Math.min(c_width, c_height));        double scale_y=scale_x;        int iminx=(int)Math.floor(minx/scale_x);        int imaxx=(int)Math.ceil(maxx/scale_x);        int iminy=(int)Math.floor(miny/scale_y);        int imaxy=(int)Math.ceil(maxy/scale_y);        double vec[][]={ {minx, miny}, {minx, maxy},                          {maxx, maxy}, {maxx, miny}};        boolean around= (minx<0 && maxx>0 && miny<0 && maxy>0);        boolean acrossx=miny<0 && maxy>0;        boolean acrossy=minx<0 && maxx>0;        double maxmod=getMaxMod(vec, around, acrossx, acrossy);        MAXMOD=maxmod;        double minmod=getMinMod(vec, around, acrossx, acrossy);        // double scale_mod=chooseScale(maxmod-minmod);        double scale_mod=scale_x;        int iminmod=(int)Math.floor(minmod/scale_mod);        int imaxmod=(int)Math.ceil(maxmod/scale_mod);        boolean across=maxy>0 && miny<0 && minx<0;        double scale_ang=5;        int minang=(int)Math.floor(getMinAng(vec, around, across)/scale_ang);        int maxang=(int)Math.ceil(getMaxAng(vec, around, across)/scale_ang);        double a_width=Math.max(maxx,0)-Math.min(minx, 0);        double a_height=Math.max(maxy,0)-Math.min(miny, 0);                setLayout(new GridLayout(1, 2, 5, 5));        canvas=new NewVectorInputCanvas(this);        canvas.setBackground(Color.white);        SizeConstraint sc=new SizeConstraint(canvas, new Dimension(100, 100));        sc.setAspect(a_width, a_height);        add("", sc);        Panel pan=new Panel();        // pan.setLayout(new VerticalLayout(VerticalLayout.JUSTIFIED, 3, 0));        pan.setLayout(new GridLayout(0, 1));        Label lab=new Label("Modulo");        pan.add("", lab);        // modifica by Sav 2/99                modulus=new NumericInput((iminmod)*2*v_scale, imaxmod*2*v_scale, 0, scale_mod/(2*v_scale));        pan.add("", modulus);        lab=new Label("Angolo (gradi)");        pan.add("", lab);        angle=new NumericInput(minang, maxang, 0, scale_ang);        pan.add("", angle);        lab=new Label("Componente X");        pan.add("", lab);        xComp=new NumericInput(iminx*2*100, imaxx*2*100, 0, scale_x/(2*100));        pan.add("", xComp);        lab=new Label("Componente Y");        pan.add("", lab);        yComp=new NumericInput(iminy*2*100, imaxy*2*100, 0, scale_y/(2*100));        pan.add("", yComp);                add("", pan);        setXY(true);      }    /**     * Return the current X component      */    public double getX()      { return xComp.getValue();      }    /**     * Return the current Y component      */    public double getY()      { return yComp.getValue();      }    /**     * Set the current vector components     */    public void setValue(double x, double y)      { xComp.setValue(x);        yComp.setValue(y);        setXY(true);      }          double chooseScale(double span)      { double base=span/400;        return Functions.chooseIncrement(base);      }    double sqr(double x)      { return x*x;      }    double getMinMod(double p[][], boolean around, boolean acrossx,                                                    boolean acrossy)      { if (around)          return 0;        else          { int i;            double m=sqr(p[0][0])+sqr(p[0][1]);            for(i=1; i<4; i++)              { double mm=sqr(p[i][0])+sqr(p[i][1]);                if (mm<m)                  m=mm;                if (acrossx)                  { mm=sqr(p[i][0]);                    if (mm<m)                      m=mm;                  }                if (acrossy)                  { mm=sqr(p[i][1]);                    if (mm<m)                      m=mm;                  }              }            return Math.sqrt(m);          }      }            double getMaxMod(double p[][], boolean around, boolean acrossx,                                                   boolean acrossy)      { int i;        // modifica di Sav 2/92        // in  questo caso il modulo puÂ• essere scelto all' interno della        // massima circonferenza di centro 0 inscrivibile nel rettangolo        // descritto  da p        /*        double m=sqr(p[0][0])+sqr(p[0][1]);        for(i=1; i<4; i++)          { double mm=sqr(p[i][0])+sqr(p[i][1]);            if (mm>m)              m=mm;          }        */        // **************************************************************        double m=Math.abs(p[0][0]);        for(i=1; i<4; i++)          { double mm=Math.abs(p[i][0]);            if (mm<m)              m=mm;                      }        for(i=0; i<4; i++)          { double mm=Math.abs(p[i][1]);            if (mm<m)              m=mm;                      }                       return m;      }    int getMinAng(double p[][], boolean around, boolean across)      { if (around)          return -180;        else          { double r=Math.PI+(across? Math.PI: 0);            int i;            for(i=0; i<4; i++)              { double x=p[i][0];                double y=p[i][1];                if (Math.abs(x)+Math.abs(y)>0)                  { double rr=Math.atan2(y, x);                    if (across && rr<0)                      rr+=2*Math.PI;                    if (rr<r)                      r=rr;                  }              }            return (int)(r*180.0/Math.PI);          }      }                        int getMaxAng(double p[][], boolean around, boolean across)      { if (around)          return 180;        else          { double r=-Math.PI+(across? Math.PI: 0);            int i;            for(i=0; i<4; i++)              { double x=p[i][0];                double y=p[i][1];                if (Math.abs(x)+Math.abs(y)>0)                  { double rr=Math.atan2(y, x);                    if (across && rr<0)                      rr+=2*Math.PI;                    if (rr>r)                      r=rr;                  }              }            return (int)(r*180.0/Math.PI);          }      }    public boolean handleEvent(Event evt)      { if (evt.id==Event.ACTION_EVENT)          {            if (evt.target==modulus || evt.target==angle)              setModAngle(true);            else if (evt.target==xComp || evt.target==yComp)              setXY(true);          }        return super.handleEvent(evt);      }    void setModAngle(boolean propagate)      {        double mod=modulus.getValue();        if (mod==0) {modulus.setValue(1/(double)v_scale);mod=1/(double)v_scale;}        double ang=angle.getValue()*Math.PI/180;        double x=mod*Math.cos(ang);        double y=mod*Math.sin(ang);        int ix=xComp.getValue(true);        int iy=yComp.getValue(true);        boolean force=false;                if (x<minx)          { x=minx;            force=true;          }        else if (x>maxx)          { x=maxx;            force=true;          }        if (y<miny)          { y=miny;            force=true;          }        else if (y>maxy)          { y=maxy;            force=true;          }        xComp.setValue(x);        yComp.setValue(y);        if (force)        {  setXY(false);}        canvas.repaint();      }    void setXY(boolean propagate)      { double x=xComp.getValue();        double y=yComp.getValue();        double mod=Math.sqrt(sqr(x)+sqr(y));        double r=Math.atan2(y, x);        boolean across= miny<0 && maxy>0 && minx<0 && maxx<0;        if (r<0 && across)          r+=2*Math.PI;        int ang=(int)Math.floor(r*180/Math.PI+0.4999);         if (mod==0) {mod=1/(double)v_scale;}                 if (mod<=MAXMOD)        {         modulus.setValue(mod);         angle.setValue(ang);        }        else        {          double mod2=modulus.getValue();          double ang2=angle.getValue()*Math.PI/180;          x=mod2*Math.cos(ang2);          y=mod2*Math.sin(ang2);          xComp.setValue(x);          yComp.setValue(y);        }        canvas.repaint();      }            }class NewVectorInputCanvas extends Canvas  { Color gridcol=Color.green;    Color arrowcol=Color.blue;    Color bgcol=Color.white;    double arrowang=Math.PI/10;    double arrowsin=Math.sin(Math.PI-arrowang);    double arrowcos=Math.cos(Math.PI-arrowang);    int arrowlen=8;    double minx, miny, maxx, maxy;    NewVectorInput vi;    CursorChanger cursor;    NewVectorInputCanvas(NewVectorInput parent)      { vi=parent;        minx=Math.min(vi.minx, 0);        maxx=Math.max(vi.maxx, 0);        miny=Math.min(vi.miny, 0);        maxy=Math.max(vi.maxy, 0);        cursor=new CursorChanger(this);      }    Point cvt(double x, double y)      { Dimension d=size();        int ix=1+(int)((x-minx)/(maxx-minx)*(d.width-2));        int iy=1+(int)((maxy-y)/(maxy-miny)*(d.height-2));        return new Point(ix, iy);      }    double cvtX(int ix)      { Dimension d=size();        return minx + (ix-1)*(maxx-minx)/(d.width-2);        }    double cvtY(int iy)      { Dimension d=size();        return maxy - (iy-1)*(maxy-miny)/(d.height-2);        }    public void paint(Graphics g)      { Point zero=cvt(0,0);        Dimension d=size();        // Draw the axes        g.setColor(gridcol);        g.drawLine(0, zero.y, d.width, zero.y);        g.drawLine(zero.x, 0, zero.x, d.height);        g.setColor(arrowcol);                // Draw the line          double x=vi.xComp.getValue();        double y=vi.yComp.getValue();        Point xy=cvt(x, y);        g.drawLine(zero.x, zero.y, xy.x, xy.y);        // Compute the arrows coords        double m=Math.sqrt(vi.sqr(x)+vi.sqr(y));        double s=y/m;        double c=x/m;        double s1=s*arrowcos+c*arrowsin;        double c1=c*arrowcos-s*arrowsin;        double s2=s*arrowcos-c*arrowsin;        double c2=c*arrowcos+s*arrowsin;        int dx1=(int)(arrowlen*c1);        int dy1=(int)(arrowlen*s1);        int dx2=(int)(arrowlen*c2);        int dy2=(int)(arrowlen*s2);        // Draw the arrow        g.drawLine(xy.x, xy.y, xy.x+dx1, xy.y-dy1);        g.drawLine(xy.x, xy.y, xy.x+dx2, xy.y-dy2);      }    public boolean mouseDown(Event evt, int x, int y)      { setCoords(x, y);        return true;      }    public boolean mouseDrag(Event evt, int x, int y)      { setCoords(x, y);        return true;      }    void setCoords(int ix, int iy)      { int cx=vi.xComp.getValue(true);        int cy=vi.yComp.getValue(true);        double x=cvtX(ix);        double y=cvtY(iy);        vi.xComp.setValue(x);        vi.yComp.setValue(y);        if (cx!=vi.xComp.getValue(true) ||            cy!=vi.yComp.getValue(true))          vi.setXY(true);      }    public boolean mouseEnter(Event evt, int x, int y)      { cursor.setCursor(Frame.CROSSHAIR_CURSOR);        return true;      }    public boolean mouseExit(Event evt, int x, int y)      { cursor.setCursor();        return true;      }  } 