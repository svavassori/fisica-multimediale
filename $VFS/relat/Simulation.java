package relat;import relat.*;import util.*;import numeric.*;/** * A class for the simulation of relativistic motion * @author Pasquale Foggia * @version 0.99, Jan 1997 */public class Simulation  {     protected double t[];    protected double x[], v[], a[];    protected int steps=0;    protected Settings settings;    protected static final double lightSpeed=2.998E8;        public Simulation(Settings settings)      { this.settings=settings;      }    protected double gamma(double v)      { return Math.sqrt(1-(v/lightSpeed)*(v/lightSpeed));      }    protected double timeForSpeed(double v)      { return settings.massa/settings.forza * v /               gamma(v);      }        /**     * Runs the simulation sampling a number of steps      * indicated by the user.     */        public synchronized void run(int steps)      { this.steps=steps;        t=new double[steps];        x=new double[steps];        v=new double[steps];        a=new double[steps];        double F=settings.forza;        double F2=F*F;        double m0=settings.massa;        double m02=m0*m0;        double c=lightSpeed;        double c2=c*c;                        double tmax=timeForSpeed(settings.maxSpeed*lightSpeed);        double timeStep=tmax/(steps-1);        int i;        for(i=0; i<steps; i++)          { t[i]=i*timeStep;            double t2=t[i]*t[i];            v[i]=c*Math.sqrt(F2*t2/(m02*c2+F2*t2));             x[i]=c2*m0/F*(Math.sqrt(1+F2*t2/(c2*m02))-1);            double gam=gamma(v[i]);            a[i]=F/m0*gam*gam*gam;          }      }    /**     * Returns the number of saved steps     */    public synchronized int getStepCount()      { return steps;      }    public synchronized double getTime(int step)      { return t[step];      }    public synchronized double getX(int step)      { return x[step];      }    public synchronized double getY(int step)      { return 0;      }    /**     * Returns the min and max values of x and y     * xx[0] and yy[0] will receive the min,     * xx[1] and yy[1] will receive the max.     */    public synchronized void getMinMaxXY(double xx[], double yy[])      { int i;        if (steps<1)          { xx[0]=0;            yy[0]=0;            xx[1]=0;            yy[1]=0;            return;          }        xx[0]=x[0];        xx[1]=x[0];        yy[0]=0;        yy[1]=0;        for(i=1; i<steps; i++)          { if (x[i]<xx[0])              xx[0]=x[i];            else if (x[i]>xx[1])              xx[1]=x[i];          }                }    /**     * Types of output information available     * The time is included, and should be always outpun n. 0     */    public synchronized int getOutputCount()      { return 13;      }    /**     * Names associated to the output information     * The time is included, and should be always outpun n. 0     */    public synchronized String getOutputName(int i)      { final String names[] = {                          "Tempo",                        "Posizione relativistica",                        "Posizione classica",                        "Velocità relativistica",                        "Velocità classica",                        "Accelerazione relativistica",                        "Accelerazione classica",                        "Energia cinetica relativistica",                        "Energia cinetica classica",                        "Massa relativistica",                        "Velocità relativistica al quadrato",                        "Velocità classica al quadrato",                        "Velocità relativistica / c"                      };        return names[i];      }    /**     * Short names associated to the output information     * The time is included, and should be always outpun n. 0     */    public synchronized String getOutputShortName(int i)      { final String names[] = {                          "t[s]",                        "Srel[m]",                        "Sclas[m]",                        "Vrel[m/s]",                        "Vclas[m/s]",                        "Arel[m/s^2]",                        "Acls[m/s^2]",                        "Erel[J]",                        "Eclas[J]",                        "Mrel[kg]",                        "Vr2[(m/s)^2]",                        "Vc2[(m/s)^2]",                        "Vrel/c"                      };        return names[i];      }    /**     * Value of output information     * The time is included, and should be always outpun n. 0     */    public synchronized double getOutput(int i, int step)      { double aclas=settings.forza/settings.massa;        switch(i)          { case 0:              return t[step];            case 1:              return x[step];            case 2:              return 0.5*aclas*t[step]*t[step];            case 3:              return v[step];            case 4:              return aclas*t[step];            case 5:              return a[step];            case 6:              return aclas;            case 7:               return lightSpeed*lightSpeed*(getOutput(9, step)-settings.massa);            case 8:              return 0.5*settings.massa*Functions.sqr(aclas*t[step]);            case 9:              return settings.massa/gamma(v[step]);            case 10:              return Functions.sqr(getOutput(3, step));            case 11:              return Functions.sqr(getOutput(4, step));            case 12:              return v[step]/lightSpeed;            default:              throw new IllegalArgumentException();          }      }        public String getTableHeading()      { int i;        int n=getOutputCount();        StringBuffer sb=new StringBuffer();        for(i=0; i<n; i++)          {             sb.append(Format.format("^11", getOutputShortName(i)));            sb.append(" ");          }        return sb.toString();      }    public synchronized String getTableRow(int step)      { int i;        int n=getOutputCount();        StringBuffer sb=new StringBuffer();        for(i=0; i<n; i++)          {             sb.append(Format.format_e("11.3", getOutput(i, step)));            sb.append(" ");          }        return sb.toString();      }    /**     * Returns the vector of the indices of the most interesting outputs     * to be displayed during the simulation     */    public int[] getInterestingInfo()      { int i, n=getOutputCount();        int idx[]=new int[n];        for(i=0; i<n; i++)          idx[i]=i;        return idx;      }  }