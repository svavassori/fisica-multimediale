package ottica;import java.awt.*;import ui.*;import numeric.*;import util.*;/** * Rappresenta le caratteristiche comuni alle varie simulazioni */public /*abstract*/ class SimulationDisplay extends Canvas implements Painter  { protected boolean oggetto=false;    protected boolean raggio=false;    protected Settings settings;    protected PaintableCanvas legenda;    protected StatusDisplayer status;    public static final int ROSSO=0,                            GIALLO=1,                            BLU=2;    protected static final Color colore[]={ Color.red,                                             Color.orange,                                             Color.blue };    protected int coloreRaggio=ROSSO;    protected static final Color coloreOggetto=Color.green;    protected static final Color coloreImmagine=Color.red;    protected CoordinateMapper map;    protected AxesDrawer axes;    protected Dimension dim;    protected Insets insets;    protected CursorChanger curs;    private boolean dragging=false;    private int     drag_x1, drag_y1, drag_x2, drag_y2;    protected static final Color glassColor=new Color(192, 255, 255);        public SimulationDisplay(Settings settings, PaintableCanvas legenda,                             StatusDisplayer status)      { this.settings=settings;        this.legenda=legenda;        this.status=status;        map=new CoordinateMapper();        map.setIsometric(true);        axes=new AxesDrawer(map);        curs=new CursorChanger(this);        setBackground(Color.white);        recomputeWindow();        cleanUp();                repaint();      }    public void set(Settings settings)      { this.settings=settings;        cleanUp();        repaint();      }    /**     * Riaggiorna la finestra a fronte di un cambiamento dei      * parametri     */    protected void cleanUp()      {      }    /**     * Imposta il colore del raggio, a scelta tra ROSSO, GIALLO e BLU     */    public void setColoreRaggio(int col)      { coloreRaggio=col;        legenda.repaint();      }    /**     * Disegna la leggenda     */    public /*abstract*/ void paint(Component com, Graphics g) {};    /**     * vero se puo' visualizzare un oggetto e la sua immagine     */    public /*abstract*/ boolean canDisplayOggetto() {return false;};    /**     * vero se puo' visualizzare il percorso di un raggio luminoso     */    public /*abstract*/ boolean canDisplayRaggio() {return false;};    /**     * Passa in modo "visualizzazione oggetto"     */    public void displayOggetto()      { if (canDisplayOggetto())          { oggetto=true;            raggio=false;            repaint();          }      }    /**     * Passa in modo "visualizzazione raggio"     */    public void displayRaggio()      { if (canDisplayRaggio())          { oggetto=false;            raggio=true;            repaint();          }      }    /**     * Ricalcola il mapping tra coordinate logiche e coordinate reali     */    protected void recomputeWindow()      {         map.set(-1.0, -0.8, 1.0, 0.8);        Font font=new Font("Courier", Font.PLAIN, 10);        FontMetrics fm=getFontMetrics(font);        insets=new Insets(0, 0, 0, 0);        insets.top=10;        insets.bottom=fm.getHeight()+13;        insets.left=6*fm.charWidth('A')+10;        insets.right=2*fm.charWidth('A')+10;        map.set(size(), insets);      }          /**     * Ridisegna la legenda quando deve ridisegnare la simulazione     */    public void repaint()      { legenda.repaint();        super.repaint();      }    /**     * Ridisegna la finestra     */    public void paint(Graphics g)      {         Dimension d=size();        if (dim==null || d.width!=dim.width || d.height!=dim.height)          { dim=d;            map.set(dim, insets);          }        g.setColor(Color.blue);        g.drawRect(insets.left, insets.top,                   dim.width-insets.left-insets.right,                   dim.height-insets.top-insets.bottom);        Point pt=new Point(insets.left, dim.height-insets.bottom);        axes.drawAxes(g, pt);      }    /**     * Converte da coordinate reali a coordinate in pixel     */    Point realToPixel(double x, double y)      { return map.realToPixel(x, y);      }    /**     * Converte da coordinate in pixel a coordinate reali     */    void pixelToReal(int ix, int iy, double coords[])      { map.pixelToReal(ix, iy, coords);      }          /**     * Restituisce true se il punto (in coordinate reali)     * e' attivo, ovvero puo' essere usato per il posizionamento     * di un oggetto o un raggio     */    protected /*abstract*/ boolean activePoint(double x, double y) {return false;};    /**     * Restituisce true se il punto (in pixels)      * e' attivo, ovvero puo' essere usato per il posizionamento     * di un oggetto o un raggio. Il punto e' attivo se:     *   a) si trova nel rettangolo delimitato da insets     * E      *   b) risulta true activePoint     * @see #activePoint     */    protected boolean activePixel(int x, int y)      { double z[]={0, 0};        pixelToReal(x,y,z);        if (x>insets.left && y>insets.top &&            x<dim.width-insets.right && y<dim.height-insets.bottom &&            activePoint(z[0], z[1]))          return true;        else          return false;      }    /**     * Gestisce l'uscita del mouse dalla finestra cambiando il cursore     */    public boolean mouseExit(Event evt, int x, int y)      { curs.setCursor(Frame.DEFAULT_CURSOR);        if (dragging)          { xorDragArrow();            dragging=false;          }        return true;      }    /**     * Gestisce lo spostamento del mouse, cambiando cursore quando     * passa sull'area attiva     */    public boolean mouseMove(Event evt, int x, int y)      { double z[]={0, 0};        int cursor=activePixel(x, y)?                         Frame.CROSSHAIR_CURSOR:                       Frame.DEFAULT_CURSOR;        if (curs.getCursorType()!=cursor)          curs.setCursor(cursor);        return true;      }    /**     * Se il mouse e' premuto su un punto attivo, inizia a definire il     * raggio o l'oggetto     */    public boolean mouseDown(Event evt, int x, int y)      { if (activePixel(x, y) && (oggetto || raggio))          { drag_x1=drag_x2=x;            drag_y1=drag_y2=y;            if (oggetto)              { Point zero=realToPixel(0, 0);                drag_y1=zero.y;              }            dragging=true;            xorDragArrow();            updateInfo();          }        return true;      }    /**     * Se c'e' uno spostamento del mouse mentre sta definendo     * il raggio o l'oggetto, aggiorna la freccia.     */    public boolean mouseDrag(Event evt, int x, int y)      { if (dragging)          { if (activePixel(x, y))              { xorDragArrow();                drag_x2=x;                drag_y2=y;                if (oggetto)                  { drag_x1=x;                  }                xorDragArrow();                updateInfo();              }          }        return true;      }    /**     * Se viene rilasciato il mouse button mentre si e' in fase di dragging     * genera l'oggetto o il raggio     */    public boolean mouseUp(Event evt, int x, int y)      { if (dragging)          { xorDragArrow();            dragging=false;            if (oggetto)              { double z[]={0,0};                pixelToReal(drag_x2, drag_y2, z);                inserisciOggetto(z[0], z[1]);              }            else // if (raggio)              { if (drag_x1!=drag_x2 || drag_y1!=drag_y2)                  { double z1[]={0,0};                    double z2[]={0,0};                    pixelToReal(drag_x1, drag_y1, z1);                    pixelToReal(drag_x2, drag_y2, z2);                    double ang=Math.atan2(z2[1]-z1[1], z2[0]-z1[0]);                    inserisciRaggio(z1[0], z1[1], ang);                  }              }          }        return true;      }             public void drawArrow(Graphics g, int x1, int y1, int x2, int y2)      {        double arrowang=Math.PI/10;        double arrowsin=Math.sin(Math.PI-arrowang);        double arrowcos=Math.cos(Math.PI-arrowang);        int arrowlen=8;        g.drawLine(x1, y1, x2, y2);        // Compute the arrows coords        double m=Functions.hypot(x2-x1, y2-y1)+1e-9;        double s=(y2-y1)/m;        double c=(x2-x1)/m;        double s1=s*arrowcos+c*arrowsin;        double c1=c*arrowcos-s*arrowsin;        double s2=s*arrowcos-c*arrowsin;        double c2=c*arrowcos+s*arrowsin;        int dx1=(int)(arrowlen*c1);        int dy1=(int)(arrowlen*s1);        int dx2=(int)(arrowlen*c2);        int dy2=(int)(arrowlen*s2);        // Draw the arrow        g.drawLine(x2, y2, x2+dx1, y2+dy1);        g.drawLine(x2, y2, x2+dx2, y2+dy2);      }    /**     * Disegna in XOR mode la freccia usata per la definizione di     * raggio o oggetto     */    protected void xorDragArrow()      { Graphics g=getGraphics();        g.setColor(Color.green);        g.setXORMode(Color.white);        drawArrow(g, drag_x1, drag_y1, drag_x2, drag_y2);        g.setPaintMode();      }        /**     * Aggiorna le informazioni sull'oggetto o raggio in fase di inserimento     */    protected void updateInfo()      { if (status==null)          return;        if (dragging)          { double z1[]={0,0};            double z2[]={0,0};            pixelToReal(drag_x1, drag_y1, z1);            pixelToReal(drag_x2, drag_y2, z2);            if (oggetto)              status.showStatus("Oggetto: posizione X="+                                 Format.format(".3", z2[0])+                                 "m  altezza="+                                 Format.format(".3", z2[1])+"m");            else              { double ang=Math.atan2(z2[1]-z1[1], z2[0]-z1[0])*180/Math.PI;                status.showStatus("Raggio: X="+                                 Format.format(".3", z1[0])+                                 "m Y="+                                 Format.format(".3", z1[1])+                                 "m  angolo="+                                 Format.format(".1", ang)+                                 "Â°");              }                                           }        else          status.showStatus("");      }    /**     * Inserisce un nuovo oggetto     * Da ridefinire nelle sottoclassi     */    protected void inserisciOggetto(double x, double y)      {      }    /**     * Inserisce un nuovo raggio     * Da ridefinire nelle sottoclassi     */    protected void inserisciRaggio(double x, double y, double ang)      {      }    /**     * Calcola l'angolo di rifrazione in funzione dell'angolo di incidenza.     * Un angolo di incidenza tra PI/2 e 3*PI/2 indica che il raggio proviene     * dall'interno del materiale.     * @param ang  angolo tra il raggio e la normale entrante nel materiale     */    protected double angoloRifrazione(double ang)      {         double n=indiceRifrazione();        double sin=Math.sin(ang);        double cos=Math.cos(ang);        if (cos<0)          n=1/n;        double sin2=sin/n;        if (Math.abs(sin2)>1.0)          { // Riflessione            return Math.PI-ang;          }                  double ang2=Math.asin(sin2);        if (cos<0)          ang2=Math.PI-ang2;         return ang2;      }  /**   * Calcola l'indice di rifrazione   */  protected double indiceRifrazione()    {       int col=coloreRaggio;      if (oggetto)          col=GIALLO;      return indiceRifrazione(col);    }  /**   * Calcola l'indice di rifrazione per uno specifico colore   */  protected double indiceRifrazione(int col)    { double n;      if (settings.materiale==Settings.USER)          { switch(col)              { case ROSSO: 	n=settings.rifraz_rosso;              			break;                case GIALLO: 	n=settings.rifraz_giallo;              			break;                case BLU: 	n=settings.rifraz_blu;              			break;                default:	n=1.0;                		break;              }          }      else          n=Settings.tabella_rifrazione[settings.materiale][col];      return n;    }    /**     * Controlla se per un dato angolo di incidenza c'e' vera rifrazione o     * invece il raggio e' riflesso     * Un angolo di incidenza tra PI/2 e 3*PI/2 indica che il raggio proviene     * dall'interno del materiale.     * @param ang  angolo tra il raggio e la normale entrante nel materiale     */    protected boolean veraRifrazione(double ang)      {         double n=indiceRifrazione();        double sin=Math.sin(ang);        double cos=Math.cos(ang);        if (cos<0)          n=1/n;        double sin2=sin/n;        if (Math.abs(sin2)>1.0)          { // Riflessione            return false;          }        else          { // Vera rifrazione            return true;          }      }              /**     * Imposta il clipping rectangle al rettangolo in cui devono essere     * disegnate le simulazioni     * Restituisce il vecchio clipping rect, o null se non era     * definito.     */    Rectangle clip(Graphics g)      { return clip(g,              new Rectangle(insets.left+1, insets.top+1,                           dim.width-insets.left-insets.right-1,                           dim.height-insets.top-insets.bottom-1));      }    /**     * Imposta il clipping rectangle al rettangolo specificato,     * o all'intera area della canvas se il rettangolo e' null.      * Restituisce il vecchio clipping rect, o null se non era     * definito.     */    Rectangle clip(Graphics g, Rectangle r)      {         Rectangle old=new Rectangle(0,0,100,100);        try {            if (r==null)                r=new Rectangle(0,0, dim.width, dim.height);            old=g.getClipRect();            g.clipRect(r.x, r.y, r.width, r.height);        } catch (NullPointerException e) {            System.out.println("aaaa");        }        return old;      }  }