package ottica;import java.awt.*;import ui.*;import numeric.*;import util.*;/** * Simulazione di un prisma rifrangente */public class PrismaDisplay extends SimulationDisplay   { boolean raggio_definito;    double raggio_x, raggio_y, raggio_ang;    double angolo_incidente[], angolo_rifratto[];    boolean riflessione[];    int num_intersezioni;    final int MAX_INTERSEZIONI=3;    static final double base_prisma[][]={{-0.6, 0.6},                                         {-0.6, -0.6},                                         {0.6,  0.6},                                         {-0.6, 0.6}};    double prisma_x[], prisma_y[];        public PrismaDisplay(Settings settings, PaintableCanvas legenda,                             StatusDisplayer status)      { super(settings, legenda, status);      }    /**     * Riaggiorna la finestra a fronte di un cambiamento dei     * parametri     */    protected void cleanUp()      { raggio_definito=false;        ricalcolaPrisma();        angolo_incidente=new double[MAX_INTERSEZIONI];        angolo_rifratto=new double[MAX_INTERSEZIONI];        riflessione=new boolean[MAX_INTERSEZIONI];        num_intersezioni=0;      }    /**     * Disegna la legenda     */    public void paint(Component com, Graphics g)      {        Dimension d=com.size();        FontMetrics fm=g.getFontMetrics();        int asc=fm.getAscent();        int h=fm.getHeight();        String str="Rifrazione attraverso un prisma";        int w=fm.stringWidth(str);        g.setColor(Color.lightGray);        g.drawString(str, (d.width-w)/2+1, asc+3+1);        g.setColor(Color.blue);        g.drawString(str, (d.width-w)/2-2, asc+3-2);        g.setColor(Color.black);        str="Angolo limite: rosso="+            Format.format(".1",                     Math.asin(1.0/indiceRifrazione(ROSSO))*180.0/Math.PI)+            "°  giallo="+            Format.format(".1",                     Math.asin(1.0/indiceRifrazione(GIALLO))*180.0/Math.PI)+            "°  blu="+            Format.format(".1",                     Math.asin(1.0/indiceRifrazione(BLU))*180.0/Math.PI)+            "°";        g.drawString(str, 10, asc+3+h);        if (!raggio_definito)          return;        int i;        for(i=0; i<num_intersezioni; i++)          { str="Raggio "+(i+1)+": ang. incid. "+                Format.format(".1", angolo_incidente[i])+                (riflessione[i]? "° ang. riflesso ": "°  ang. rifratto ")+                Format.format(".1", angolo_rifratto[i])+"°";            g.drawString(str, 10, asc+3+h*(i+2));          }      }    /**     * vero se puo' visualizzare un oggetto e la sua immagine     */    public boolean canDisplayOggetto()      { return false;      }    /**     * vero se puo' visualizzare il percorso di un raggio luminoso     */    public boolean canDisplayRaggio()      { return true;      }    /**     * Ricalcola il mapping tra coordinate logiche e coordinate reali     */    protected void recomputeWindow()      { super.recomputeWindow();        map.set(-0.6, -0.86, 1.4, 0.86);      }    /**     * Restituisce true se il punto (in coordinate reali)     * e' attivo, ovvero puo' essere usato per il posizionamento     * di un oggetto o un raggio     */    protected boolean activePoint(double x, double y)      {         return x<-0.1;      }    /**     * Inserisce un nuovo raggio     */    protected void inserisciRaggio(double x, double y, double ang)      {         // Riduce l'angolo a [-PI, PI[        ang=Functions.reduceAngle(ang);        // Se non e' diretto verso destra, non disegna nulla        double cos=Math.cos(ang);        if (cos<5e-3)          return;                raggio_definito=true;        raggio_x=x;        raggio_y=y;        raggio_ang=ang;        num_intersezioni=0;        Graphics g=getGraphics();        Rectangle old=clip(g);        disegnaRaggio(g);        clip(g, old);        legenda.repaint();      }    public void paint(Graphics g)    {   super.paint(g);        // Disegna il prisma         Rectangle old=clip(g);        int i;        Polygon poly=new Polygon();        for(i=0; i<3; i++)          { Point pt=realToPixel(prisma_x[i], prisma_y[i]);            poly.addPoint(pt.x, pt.y);          }        g.setColor(glassColor);        g.fillPolygon(poly);        // disegna l'ultimo raggio        if (raggio_definito)          disegnaRaggio(g);                 clip(g, old);      }         /**     * Disegna il raggio     * e aggiorna i parametri     */     void disegnaRaggio(Graphics g)      { g.setColor(colore[coloreRaggio]);        num_intersezioni=0;        PrismaIntersezione pi;        int k=0;        double x=raggio_x;        double y=raggio_y;        double ang=raggio_ang;        while (k<MAX_INTERSEZIONI+2 &&               (pi=intersezione(x, y, ang))!=null)          { double ang2=angoloRifrazione(pi.ang);            if (k<MAX_INTERSEZIONI)              { angolo_incidente[k]=pi.ang*180/Math.PI;                angolo_rifratto[k]=ang2*180/Math.PI;                if (angolo_incidente[k]<-90)                  { angolo_incidente[k]+=180;                    angolo_rifratto[k]+=180;                    if (angolo_rifratto[k]>=360)                      angolo_rifratto[k]-=360;                  }                else if (angolo_incidente[k]>90)                  { angolo_incidente[k]-=180;                    angolo_rifratto[k]-=180;                    if (angolo_rifratto[k]<0)                      angolo_rifratto[k]+=360;                  }                riflessione[k]=!veraRifrazione(pi.ang);                num_intersezioni++;              }            Point pta=realToPixel(x, y);            Point ptb=realToPixel(pi.x, pi.y);            g.drawLine(pta.x, pta.y, ptb.x, ptb.y);            x=pi.x;            y=pi.y;            ang=Functions.reduceAngle(ang+ang2-pi.ang);            k++;          }        if (k<MAX_INTERSEZIONI+2)          { double xx=x+30*Math.cos(ang);            double yy=y+30*Math.sin(ang);            Point pta=realToPixel(x, y);            Point ptb=realToPixel(xx, yy);            g.drawLine(pta.x, pta.y, ptb.x, ptb.y);          }                     }      /**     * Ricalcola i vertici del prisma con la rotazione corrente     */    void ricalcolaPrisma()      { double rot=settings.prisma_angolo*Math.PI/4;        double sin=Math.sin(rot);        double cos=Math.cos(rot);        int i;        prisma_x=new double[4];        prisma_y=new double[4];        for(i=0; i<base_prisma.length; i++)          { prisma_x[i]=base_prisma[i][0]*cos-base_prisma[i][1]*sin;            prisma_y[i]=base_prisma[i][1]*cos+base_prisma[i][0]*sin;          }        double min_x=prisma_x[0];        double min_y=prisma_y[0];        double max_y=prisma_y[0];        for(i=1; i<prisma_x.length; i++)          { if (prisma_x[i]<min_x)              min_x=prisma_x[i];            if (prisma_y[i]<min_y)              min_y=prisma_y[i];            else if (prisma_y[i]>max_y)              max_y=prisma_y[i];          }        for(i=0; i<prisma_x.length; i++)          { prisma_x[i]-=min_x;            prisma_y[i]-=(min_y+max_y)/2;          }              }    /**     * Calcola l'intersezione di un raggio con il prisma     * Restituisce null se non c'e' intersezione     */    PrismaIntersezione intersezione(double x, double y, double ang)      { int i;        double sin=Math.sin(ang);        double cos=Math.cos(ang);        double minang=0, mint=0;        double minx=0, miny=0;        int    minlato=-1;        for(i=0; i<prisma_x.length-1; i++)          { double x1=prisma_x[i];            double y1=prisma_y[i];            double dx=prisma_x[i+1]-x1;            double dy=prisma_y[i+1]-y1;            //            // Risolve il sistema            //  x + t*cos = x1+t1*dx            //  y + t*sin = y1+t1*dy            //            double disc=-dx*sin+dy*cos;            if (Math.abs(disc)<1e-5)              continue;            double t1=(-(x-x1)*sin+(y-y1)*cos)/disc;            double t=(dx*(y-y1)-dy*(x-x1))/disc;            if (t<=1e-3 || t1<=1e-5 || t1>=1.0-1e-5)              continue;            if (minlato<0 || t<mint)              { minlato=i;                mint=t;                minx=x+t*cos;                miny=y+t*sin;                double cc=sin*dx-cos*dy;                double ss=-sin*dy-cos*dx;                minang=Math.atan2(ss, cc);              }          }        if (minlato<0)          return null;        PrismaIntersezione pi=new PrismaIntersezione();        pi.lato=minlato;        pi.x=minx;        pi.y=miny;        pi.t=mint;        pi.ang=minang;        return pi;      }  }