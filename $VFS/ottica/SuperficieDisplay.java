package ottica;import java.awt.*;import ui.*;import util.*;import numeric.*;/** * Simulazione di una superficie riflettente o rifrangente */public class SuperficieDisplay extends SimulationDisplay   { protected static final double MAX_ANG=80*Math.PI/180;    double max_ang;    boolean raggio_definito;    boolean raggio_intersezione;    double raggio_x, raggio_y, raggio_ang;    double angolo_incidente, angolo_rifratto;    boolean oggetto_definito;    double oggetto_x, oggetto_y;    double immagine_x, immagine_y;    double R, f1, f2;        public SuperficieDisplay(Settings settings, PaintableCanvas legenda,                             StatusDisplayer status)      { super(settings, legenda, status);        calcolaParametri();      }    /**     * Riaggiorna la finestra a fronte di un cambiamento dei     * parametri     */    protected void cleanUp()      { raggio_definito=false;        oggetto_definito=false;        calcolaParametri();      }    public void repaint () {        super.repaint();    }    /**     * Disegna la leggenda     */    public void paint(Component com, Graphics g)      {        Dimension d=com.size();        FontMetrics fm=g.getFontMetrics();        int asc=fm.getAscent();        int h=fm.getHeight();        String str;        if (oggetto)          str="Immagine di un oggetto attraverso una superficie";        else if (settings.superficie_riflettente)          str="Riflessione su una superficie";        else          str="Rifrazione attraverso una superficie";        int w=fm.stringWidth(str);        g.setColor(Color.lightGray);        g.drawString(str, (d.width-w)/2+1, asc+3+1);        g.setColor(Color.blue);        g.drawString(str, (d.width-w)/2-2, asc+3-2);                if (oggetto)          { g.setColor(Color.black);            if (settings.tipo_superficie!=Settings.PIANA)              { if (settings.superficie_riflettente)                  str="Fuoco: "+                      Format.format(".3", f2)+                      "m";                else                  str="Fuochi: f1="+                    Format.format(".3", f1)+                    "m  f2="+                    Format.format(".3", f2)+"m";                g.drawString(str, 10, asc+3+h);              }            if (oggetto_definito)              { str="Oggetto:  pos="+Format.format(".3", oggetto_x)+                    "m  altezza="+Format.format(".3", oggetto_y)+"m";                g.drawString(str, 30, asc+3+2*h);                str="Immagine: pos="+Format.format(".3", immagine_x)+                    "m  altezza="+Format.format(".3", immagine_y)+"m";                g.drawString(str, 30, asc+3+3*h);                g.setColor(coloreOggetto);                g.fillRect(10, 3+2*h, 10, asc);                g.setColor(coloreImmagine);                g.fillRect(10, 3+3*h, 10, asc);              }          }        else if (raggio && raggio_definito && raggio_intersezione)          { g.setColor(Color.black);            g.drawString("Angolo del raggio incidente: "+                          Format.format("5.1", angolo_incidente)+"°",                          20, asc+h+6);            if (settings.superficie_riflettente)              str="riflesso";            else              str="rifratto";            g.drawString("Angolo del raggio "+str+":  "+                          Format.format("5.1", angolo_rifratto)+"°",                          20, asc+2*h+6);          }      }    /**     * vero se puo' visualizzare un oggetto e la sua immagine     */    public boolean canDisplayOggetto()      { return true;      }    /**     * vero se puo' visualizzare il percorso di un raggio luminoso     */    public boolean canDisplayRaggio()      { return true;      }    /**     * Restituisce true se il punto (in coordinate reali)     * e' attivo, ovvero puo' essere usato per il posizionamento     * di un oggetto o un raggio     */    protected boolean activePoint(double x, double y)      { return x<-0.05;      }    /**     * Calcola i parametri della superficie     * (fuochi e max. angolo)     */    void calcolaParametri()      { if (settings.tipo_superficie==Settings.PIANA)          return;        R=settings.superficie_raggio;        if (settings.tipo_superficie==Settings.CONCAVA)          R=-R;        double z[]={0,0};        pixelToReal(100, insets.top, z);        double h=z[1];        if (Math.abs(R)*Math.sin(MAX_ANG)<=h)          max_ang=MAX_ANG;        else          max_ang=Math.asin(Math.abs(h/R));        if (settings.superficie_riflettente)          { f1=-R/2;            f2=R/2;          }        else          { double n=indiceRifrazione();            f1=-R/(n-1);            f2=n*R/(n-1);          }      }    /**     * Inserisce un nuovo raggio     */    protected void inserisciRaggio(double x, double y, double ang)      {         // Riduce l'angolo a [-PI, PI[        ang=Functions.reduceAngle(ang);        // Se non e' diretto verso destra, non disegna nulla        double cos=Math.cos(ang);        if (cos<5e-3)          return;                raggio_definito=true;        raggio_x=x;        raggio_y=y;        raggio_ang=ang;        Graphics g=getGraphics();        Rectangle old=clip(g);        disegnaRaggio(g);        clip(g, old);        legenda.repaint();      }    /**     * Inserisce un nuovo oggetto     */    protected void inserisciOggetto(double x, double y)      { oggetto_definito=true;        oggetto_x=x;        oggetto_y=y;        if (settings.superficie_riflettente)          { if (settings.tipo_superficie==Settings.PIANA)              { immagine_x=-oggetto_x;                immagine_y=oggetto_y;              }            else              { immagine_x=1/(2/R - 1/oggetto_x);                immagine_y=-oggetto_y*immagine_x/oggetto_x;               }          }        else          { double n=indiceRifrazione();            if (settings.tipo_superficie==Settings.PIANA)              { immagine_x=oggetto_x*n;                immagine_y=oggetto_y;              }            else              { immagine_x=n/((n-1)/R+1/oggetto_x);                immagine_y=oggetto_y*immagine_x/oggetto_x/n;              }          }        repaint();      }       public void _paint(Graphics g)      {         Dimension d=size();        g.drawOval(0,0, d.width, d.height);        if (dim==null || d.width!=dim.width || d.height!=dim.height)          { dim=d;            map.set(dim, insets);          }        g.setColor(Color.blue);        g.drawRect(insets.left, insets.top,                   dim.width-insets.left-insets.right,                   dim.height-insets.top-insets.bottom);        Point pt=new Point(insets.left, dim.height-insets.bottom);        axes.drawAxes(g, pt);      }   public void paint(Graphics g) {        super.paint(g);        Rectangle old=clip(g);        Point zero=realToPixel(0, 0);        // Disegna l'asse ottico        g.setColor(Color.blue);        g.drawLine(0, zero.y, dim.width, zero.y);        // Marca i fuochi        if (settings.tipo_superficie!=Settings.PIANA)          { if (!settings.superficie_riflettente)              { Point ptf1=realToPixel(f1, 0);                g.drawLine(ptf1.x, zero.y-5, ptf1.x, zero.y+5);                g.drawString("f1", ptf1.x, zero.y+12);              }            Point ptf2=realToPixel(f2, 0);            g.drawLine(ptf2.x, zero.y-5, ptf2.x, zero.y+5);            g.drawString(settings.superficie_riflettente? "f": "f2",                          ptf2.x, zero.y+12);          }        // Disegna la superficie        g.setColor(glassColor);        if (settings.tipo_superficie==Settings.PIANA)           { Point pta=new Point(zero.x, insets.top-10);            Point ptb=new Point(zero.x, dim.height-insets.bottom+10);            g.drawLine(pta.x, pta.y, ptb.x, ptb.y);            g.drawLine(pta.x+1, pta.y, ptb.x+1, ptb.y);          }        else // Superficie sferica          { Point ptc=realToPixel(R, 0);            int r=zero.x-ptc.x;            if (r<0)              r=-r;            int ang=(int)(max_ang*180/Math.PI);            int start;            if (R<0)              start=-ang;            else              start=180-ang;            g.drawArc(ptc.x-r, ptc.y-r, 2*r, 2*r, start, 2*ang);            g.drawArc(ptc.x-r+1, ptc.y-r, 2*r, 2*r, start, 2*ang);          }        // Disegna l'oggetto        if (oggetto && oggetto_definito)          { Point pto=realToPixel(oggetto_x, oggetto_y);            g.setColor(coloreOggetto);            drawArrow(g, pto.x, zero.y, pto.x, pto.y);            Point pti=realToPixel(immagine_x, immagine_y);            g.setColor(coloreImmagine);            drawArrow(g, pti.x, zero.y, pti.x, pti.y);          }        // Disegna l'ultimo raggio definito        if (raggio && raggio_definito)          disegnaRaggio(g);        clip(g, old);      }    /**     * Disegna un raggio e ne determina i parametri     */    void disegnaRaggio(Graphics g)      { g.setColor(colore[coloreRaggio]);        SuperficieIntersezione si=intersezione(raggio_x, raggio_y, raggio_ang);        if (si==null)          { raggio_intersezione=false;            Point pta=realToPixel(raggio_x, raggio_y);            double xx=raggio_x+30*Math.cos(raggio_ang);            double yy=raggio_y+30*Math.sin(raggio_ang);            Point ptb=realToPixel(xx, yy);            g.drawLine(pta.x, pta.y, ptb.x, ptb.y);          }        else          { raggio_intersezione=true;            Point pta=realToPixel(raggio_x, raggio_y);            Point ptb=realToPixel(si.x, si.y);            g.drawLine(pta.x, pta.y, ptb.x, ptb.y);            double ang2;            if (settings.superficie_riflettente)              ang2=Functions.reduceAngle(Math.PI-si.ang);            else              ang2=angoloRifrazione(si.ang);            angolo_incidente=si.ang*180/Math.PI;            angolo_rifratto=ang2*180/Math.PI;            double ang_new=raggio_ang+(ang2-si.ang);            double xx=raggio_x+30*Math.cos(ang_new);            double yy=raggio_y+30*Math.sin(ang_new);            Point ptc=realToPixel(xx, yy);            g.drawLine(ptb.x, ptb.y, ptc.x, ptc.y);          }      }    /**      * Calcola il punto di intersezione tra un raggio e la superficie     * Restituisce null se non c'e' intersezione     */    SuperficieIntersezione intersezione(double x, double y, double ang)      { if (settings.tipo_superficie==Settings.PIANA)          { double z[]={0, 0};            pixelToReal(0, insets.top, z);            double h=z[1];            double inters_y=-x*Math.tan(ang);            if (Math.abs(inters_y+y)>h)              return null;            SuperficieIntersezione si=new SuperficieIntersezione();            si.x=0;            si.y=inters_y+y;            si.ang=ang;            return si;          }        else          { double xc=R;            double yc=0;            double sin=Math.sin(ang);            double cos=Math.cos(ang);            // Risolve l'equazione            // (x+cos*t-xc)^2 + (y+sin*t-yc)^2 = R^2            // L'equazione si riduce a            // t^2 + 2*b*t +c=0, dove:            double b=cos*(x-xc)+sin*(y-yc);            double c=Functions.sqr(x-xc)+Functions.sqr(y-yc)-R*R;            double disc=b*b-c;            if (disc<=0)              { // Solo soluzioni degeneri o complesse                return null;              }            double t;            if (R>0)              t=-b-Math.sqrt(disc);            else              t=-b+Math.sqrt(disc);            if (t<1e-3)              return null;                        // Verifica se la soluzione e' accettabile            double xx=x+t*cos;            double yy=y+t*sin;            double ang2=Math.atan((yy-yc)/(xx-xc));            if (Math.abs(ang2)>Math.abs(max_ang))              return null;            SuperficieIntersezione si=new SuperficieIntersezione();            si.x=xx;            si.y=yy;            si.ang= ang-ang2;            return si;          }      }  }