package dinam1;import dinam1.*;import numeric.*;/** * Simulazione del moto con vincolo piano * @author Pasquale Foggia * @version 0.99, Dec 1997 */public class SimulationPlane extends Simulation implements ODE  {     double p[], v[], a[];    double mass, p0, v0, p00, v00;    boolean exact;    ODESolver solver=null;    ODEInterpolator interpolator=null;    Settings settings;    double plane_sin, plane_cos;    public SimulationPlane(Settings settings,                           double mass,                          double p0, double v0)        { this.settings=settings;        this.mass=mass;        this.p0=p0;        this.v0=v0;        this.p00=p0;        this.v00=v0;        double ang=settings.angolo*Math.PI/180;        plane_sin=Math.sin(ang);        plane_cos=Math.cos(ang);        t1=0;        t2=0;        exact=(settings.attrito_coulombiano==0 &&               settings.resistenza_laminare==0 &&               settings.resistenza_turbolenta==0);        x=new double[1];        x[0]=p0*plane_cos;        y=new double[1];        y[0]=p0*plane_sin;      }   public double getMass()      { return mass;      }   public double getInitialVel()      { return v00;      }   public int getOutputCount()      { return 12;      }    public String getOutputName(int i)      { final String names[]= {                           "Ascissa curvilinea",                          "Posizione X",                          "Posizione Y",                          "Velocità",                          "Velocità X",                          "Velocità Y",                          "Accelerazione",                          "Accelerazione X",                          "Accelerazione Y",                          "Energia cinetica",                          "Energia potenziale",                          "Energia"                        };        return names[i];      }    public String getOutputShortName(int i)      { final String names[]= {                           "S[m]",                          "X[m]",                          "Y[m]",                          "V[m/s]",                          "Vx[m/s]",                          "Vy[m/s]",                          "A[m/s^2]",                          "Ax[m/s^2]",                          "Ay[m/s^2]",                          "Ek[J]",                          "Ep[J]",                          "E[J]"                        };         return names[i];      }    public double getOutput(int i, int step)      { switch(i)        { case 0:            return p[step];          case 1:            return x[step];          case 2:            return y[step];          case 3:            return v[step];          case 4:            return v[step]*plane_cos;          case 5:            return v[step]*plane_sin;          case 6:            return a[step];          case 7:            return a[step]*plane_cos;          case 8:            return a[step]*plane_sin;          case 9:            return 0.5*mass*Functions.sqr(v[step]);          case 10:            return -settings.fx*x[step]-settings.fy*y[step];          case 11:            return getOutput(9, step)+getOutput(10, step);          default:            throw new IllegalArgumentException();        }      }    public void runUpTo(double endTime, double timeStep)      { if (endTime<t2)          throw new IllegalArgumentException();        t1=t2;        if (steps>0)        { p0=p[steps-1];          v0=v[steps-1];        }        steps=(int)Math.ceil((endTime-t1)/timeStep)+1;        t2=t1+(steps-1)*timeStep;        t=new double[steps];        x=new double[steps];        y=new double[steps];        p=new double[steps];        v=new double[steps];        a=new double[steps];        int i;        for(i=0; i<steps; i++)          t[i]=t1+i*timeStep;        if (exact)          { double Ax=settings.fx/mass;            double Ay=settings.fy/mass;            double A=Ax*plane_cos+Ay*plane_sin;            for(i=0; i<steps; i++)              { a[i]=A;                v[i]=v00+A*t[i];                p[i]=p00+v00*t[i]+0.5*A*t[i]*t[i];                x[i]=p[i]*plane_cos;                y[i]=p[i]*plane_sin;              }          }        else          {             if (solver==null)              { double yy[]=new double[getDimension()];                yy[0]=p0;                yy[1]=v0;                solver=new ODESolver(this, t1, yy, timeStep/4, 1e-5);                solver.setTolerant(true);              }            solver.setMaxStep(timeStep/4);            solver.setMinStep(timeStep/1000);            solver.setMaxError(1e-4+                       1e-3*Math.max( Math.abs(p0),                                      Math.abs(v0) ));            if (interpolator==null)              interpolator=new ODEInterpolator(solver);            double yy[]=new double[getDimension()];            for(i=0; i<steps; i++)              { int status=interpolator.interpolate(t[i], yy);                if (status!=ODEInterpolator.OK)                  throw new RuntimeException(                          "ODEInterpolator error: status=="+status);                                p[i]=yy[0];                x[i]=p[i]*plane_cos;                y[i]=p[i]*plane_sin;                v[i]=yy[1];                a[i]=computeAcceleration(v[i]);              }          }                      }    public int getDimension()      { return 2;      }    public void derive(double t, double yy[], double yy1[])      { yy1[0]=yy[1];        yy1[1]=computeAcceleration(yy[1]);      }    public double computeAcceleration(double v)      {         double av=Math.abs(v);        double fx=settings.fx;        double fy=settings.fy;        double ft=fx*plane_cos+fy*plane_sin;        double fn=Math.abs(fx*plane_sin)+Math.abs(fy*plane_cos);                if (av>0)          { double rl=v*settings.resistenza_laminare;            double rt=Functions.sign(v)*v*v*settings.resistenza_turbolenta;            ft-= rl+rt;          }        double attr;        if (v!=0)          attr=-Functions.sign(v)*fn*settings.attrito_coulombiano;        else          attr=-Functions.sign(ft)*fn*settings.attrito_coulombiano;                  // Per rendere continua la funzione        double base= (ft+attr)/mass;        if ( Functions.sign(ft+attr)!=Functions.sign(ft) &&             Math.abs(base)>Math.abs(v*1000))              return -v*1000;        else              return base;      }  }