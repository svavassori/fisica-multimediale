package circuiti;import ui.*;import util.*;import numeric.*;import java.awt.*;/** * Canvas che visualizza il circuito */public class CircuitoDisplay extends SpriteCanvas implements Runnable  { Circuito circuito;    StatusDisplayer status;    CursorChanger curs;    static final int GRID=Circuito.GRID;    static final int ball_radius=3;    int grid_step=-1;    static final int grid_ofsx=30;    static final int grid_ofsy=20;    boolean aggiungi_componente=false;    Point primo_punto=null;    Point secondo_punto=null;    Componente componente_aggiunto;    boolean cancella_componente=false;    boolean grafico_componente=false;    boolean tabella_componente=false;    GraficoDisplay graf;    SimulationTable tabella;    Component target;    Thread thread=null;    double startTime, duration;    public CircuitoDisplay(Circuito circuito, StatusDisplayer status)      { this.circuito=circuito;        this.status=status;        curs=new CursorChanger(this);        setBackground(Color.white);      }    public void updateBeforeResize()      { grid_step=Math.min((dim.width-2*grid_ofsx)/(GRID-1),                            (dim.height-2*grid_ofsy)/(GRID-1));        if (grid_step < 40)          grid_step=40;      }           public void paint(Graphics g)      { super.paint(g);        xorLine();      }           public void paintBackground(Graphics g, Rectangle rect)      { super.paintBackground(g, rect);        int i, j;        // Disegna i componenti        for(i=0; i<GRID; i++)          for(j=0; j<GRID; j++)            { int n1=circuito.posToNode(i,j);              int x1=grid_ofsx+i*grid_step;              int y1=grid_ofsy+j*grid_step;              int adj[]=circuito.adjacentNodes(n1);              int k;              Componente c;              for(k=0; k<adj.length; k++)                if (adj[k]<n1 && (c=circuito.get(n1, adj[k]))!=null)                  { Point p2=circuito.nodeToPos(adj[k]);                    int x2=grid_ofsx+p2.x*grid_step;                    int y2=grid_ofsy+p2.y*grid_step;                    if (circuito.isReversed(n1, adj[k]))                      c.paint(g, x2, y2, x1, y1);                    else                      c.paint(g, x1, y1, x2, y2);                  }            }        // Disegna i pallini della griglia        for(i=0; i<GRID; i++)          for(j=0; j<GRID; j++)            { int x=grid_ofsx+i*grid_step;              int y=grid_ofsy+j*grid_step;              g.setColor(Color.yellow);              g.fillOval(x-ball_radius,y-ball_radius,                         2*ball_radius, 2*ball_radius);              g.setColor(Color.black);              g.drawOval(x-ball_radius,y-ball_radius,                         2*ball_radius, 2*ball_radius);            }      }    public boolean mouseExit(Event evt, int x, int y)      { curs.setCursor();        return super.mouseExit(evt,x,y);      }    public boolean mouseEnter(Event evt, int x, int y)      { if (aggiungi_componente)          { if (curs.getCursorType() != Frame.CROSSHAIR_CURSOR)               curs.setCursor(Frame.CROSSHAIR_CURSOR);            if (primo_punto==null)              { status.showStatus("Seleziona il primo punto");              }            else              { status.showStatus("Seleziona il secondo punto");              }          }        else if (cancella_componente || grafico_componente ||                                         tabella_componente)          { if (curs.getCursorType() != Frame.CROSSHAIR_CURSOR)               curs.setCursor(Frame.CROSSHAIR_CURSOR);            String str;            if (cancella_componente)              str="da cancellare";            else              str="da visualizzare";            status.showStatus("Seleziona il componente "+str);          }                    else if (thread!=null)          curs.setCursor(Frame.HAND_CURSOR);        else          { if (curs.getCursorType() != Frame.DEFAULT_CURSOR)              curs.setCursor();          }        return super.mouseEnter(evt,x,y);      }    public boolean mouseMove(Event evt, int x, int y)      { if (aggiungi_componente)          { if (curs.getCursorType() != Frame.CROSSHAIR_CURSOR)               curs.setCursor(Frame.CROSSHAIR_CURSOR);            if (primo_punto!=null)              { xorLine();                Point closer=closerPoint(x, y);                if (adjacentPoints(primo_punto, closer))                  secondo_punto=closer;                xorLine();              }          }        else if (cancella_componente || grafico_componente ||                  tabella_componente)          { if (curs.getCursorType() != Frame.CROSSHAIR_CURSOR)               curs.setCursor(Frame.CROSSHAIR_CURSOR);            int n[]=findComponente(x, y);            Componente c;            xorLine();            if (n!=null && (c=circuito.get(n[0], n[1]))!=null)              { status.showStatus(c.toString());                primo_punto=circuito.nodeToPos(n[0]);                secondo_punto=circuito.nodeToPos(n[1]);              }            else              { String str;                if (cancella_componente)                  str="da cancellare";                else                  str="da visualizzare";                status.showStatus("Seleziona il componente "+str);                primo_punto=null;                secondo_punto=null;              }            xorLine();          }        else if (thread!=null)          curs.setCursor(Frame.HAND_CURSOR);        else          { if (curs.getCursorType() != Frame.DEFAULT_CURSOR)              curs.setCursor();            int n[]=findComponente(x, y);            Componente c;            if (n!=null && (c=circuito.get(n[0], n[1]))!=null)              status.showStatus(c.toString());            else              status.showStatus("");          }        return super.mouseMove(evt,x,y);      }    public boolean mouseDown(Event evt, int x, int y)      { Point closer=closerPoint(x,y);        int xx=grid_ofsx+closer.x*grid_step;        int yy=grid_ofsy+closer.y*grid_step;        if (evt.metaDown())          { cleanState();          }        else if (aggiungi_componente)          { if (primo_punto==null)              { if (Functions.hypot(xx - x, yy - y) < grid_step/4)                  { primo_punto=closer;                    secondo_punto=null;                    status.showStatus("Seleziona il secondo punto");                  }              }            else              { if (secondo_punto!=null && closer.equals(secondo_punto) &&                    Functions.hypot(xx - x, yy - y) < grid_step/4)                  {                     aggiungiComponente(true);                  }              }          }        else if (cancella_componente)          { if (primo_punto!=null && secondo_punto!=null)              { int n1=circuito.posToNode(primo_punto.x, primo_punto.y);                int n2=circuito.posToNode(secondo_punto.x, secondo_punto.y);                circuito.add(n1, n2, null);                cleanState();              }          }        else if (tabella_componente)          { if (primo_punto!=null && secondo_punto!=null)              { int n1=circuito.posToNode(primo_punto.x, primo_punto.y);                int n2=circuito.posToNode(secondo_punto.x, secondo_punto.y);                Componente com=circuito.get(n1, n2);                cleanState();                if (!circuito.isReversed(n1, n2))                  tabella.setData(circuito, com, n1, n2);                else                  tabella.setData(circuito, com, n2, n1);                target.deliverEvent(new Event(target, Event.ACTION_EVENT,                                               "*Tabella*"));              }          }        else if (grafico_componente)          { if (primo_punto!=null && secondo_punto!=null)              { int n1=circuito.posToNode(primo_punto.x, primo_punto.y);                int n2=circuito.posToNode(secondo_punto.x, secondo_punto.y);                cleanState();                Dialog dialog=new GraficoDialog(target, graf, circuito, n1, n2);                dialog.reshape(100, 100, 400, 400);                dialog.show();              }          }        else if (thread!=null)          { stopSimulation();            status.showStatus("Simulazione interrotta!");          }        return super.mouseDown(evt,x,y);      }    public boolean keyDown(Event evt, int key)      { if (key=='\u001B') // ESC          cleanState();        return super.keyDown(evt, key);      }    void cleanState()      { aggiungi_componente=false;        cancella_componente=false;        grafico_componente=false;        tabella_componente=false;        primo_punto=null;        secondo_punto=null;        componente_aggiunto=null;        stopSimulation();        status.showStatus("");        repaintBackground();      }    public void aggiungiComponente(Componente c)      { cleanState();        componente_aggiunto=c;        aggiungi_componente=true;        status.showStatus("Seleziona il primo punto");        curs.setCursor(Frame.CROSSHAIR_CURSOR);      }    void aggiungiComponente(boolean checkOver)      { if (!aggiungi_componente || primo_punto==null || secondo_punto==null)          return;        int n1=circuito.posToNode(primo_punto.x, primo_punto.y);        int n2=circuito.posToNode(secondo_punto.x, secondo_punto.y);        if (checkOver && circuito.get(n1,n2) != null)          { MessageBox.confirm(this, "Circuiti elettrici",               "Vuoi sovrascrivere il componente esistente?",               "*aggiungiComponente*");            repaint();          }        else          { circuito.add(n1, n2, componente_aggiunto);            cleanState();          }      }    public void cancellaComponente()      { cleanState();        cancella_componente=true;      }    public void graficoComponente(Component target, GraficoDisplay graf)      { cleanState();        grafico_componente=true;        this.target=target;        this.graf=graf;        status.showStatus("Seleziona il componente da visualizzare");      }    public void tabellaComponente(Component target, SimulationTable tabella)      { cleanState();        this.target=target;        this.tabella=tabella;        tabella_componente=true;        status.showStatus("Seleziona il componente da visualizzare");      }    Point closerPoint(int x, int y)      { int closer_x=(x-grid_ofsx+grid_step/2)/grid_step;        if (closer_x<0)          closer_x=0;        else if (closer_x>=GRID)          closer_x=GRID-1;        int closer_y=(y-grid_ofsy+grid_step/2)/grid_step;        if (closer_y<0)          closer_y=0;        else if (closer_y>=GRID)          closer_y=GRID-1;        return new Point(closer_x, closer_y);      }    boolean adjacentPoints(Point pt1, Point pt2)      { return circuito.adjacent(circuito.posToNode(pt1.x, pt1.y),                                 circuito.posToNode(pt2.x, pt2.y));      }     /**     * Disegna una linea in XOR tra i punti selezionati     */    void xorLine()      { if (primo_punto==null || secondo_punto==null)          return;        Graphics g=getGraphics();        g.setColor(Color.green);        g.setXORMode(Color.white);        int x1=primo_punto.x*grid_step+grid_ofsx;        int y1=primo_punto.y*grid_step+grid_ofsy;        int x2=secondo_punto.x*grid_step+grid_ofsx;        int y2=secondo_punto.y*grid_step+grid_ofsy;        g.drawLine(x1, y1, x2, y2);        g.dispose();      }    /**     * Trova la coppia di indici di nodo piu' vicini alla     * pos. x,y. Restituisce null se non c'e' nessun nodo vicino     */     int[] findComponente(int x, int y)      { int n[]={-1, -1};        Point closer=closerPoint(x, y);        n[0]=circuito.posToNode(closer.x, closer.y);        int adj[]=circuito.adjacentNodes(n[0]);                int i, imin=-1;        double dist, distmin=Double.POSITIVE_INFINITY;        for(i=0; i<adj.length; i++)          { Point pt=circuito.nodeToPos(adj[i]);            int xx=grid_ofsx+pt.x*grid_step;            int yy=grid_ofsy+pt.y*grid_step;            dist=Functions.hypot(x-xx, y-yy);            if (dist<distmin)              { imin=i;                distmin=dist;              }          }        if (distmin<grid_step)          { n[1]=adj[imin];            return n;          }        else          { return null;          }      }    public boolean action(Event evt, Object what)      { if ("*aggiungiComponente*".equals(what))          aggiungiComponente(false);        else if (what==null)          ;        else if (what instanceof Componente)          aggiungiComponente((Componente)what);        else if (what instanceof EseguiDialog)          { EseguiDialog ed=(EseguiDialog)what;            startTime=ed.getStartTime();            duration=ed.getDuration();            cleanState();            thread=new Thread(this);            curs.setCursor(Frame.HAND_CURSOR);            thread.setPriority(Thread.MIN_PRIORITY);            thread.start();          }        return super.action(evt, what);      }    public synchronized void stopSimulation()      { if (thread!=null)          { thread.stop();            thread=null;            curs.setCursor();          }      }    public void run()      { circuito.execute(startTime, duration, status);        thread=null;        curs.setCursor();      }      public void reset()      { cleanState();        int i, j;        for(i=0; i<Circuito.NODES; i++)          { int adj[]=circuito.adjacentNodes(i);            for(j=0; j<adj.length; j++)              circuito.add(i, adj[j], null);          }        repaintBackground();      }  }